#!/usr/bin/env perl

############################################################################           
#  Licensed to the Apache Software Foundation (ASF) under one or more                  
#  contributor license agreements.  See the NOTICE file distributed with               
#  this work for additional information regarding copyright ownership.                 
#  The ASF licenses this file to You under the Apache License, Version 2.0             
#  (the "License"); you may not use this file except in compliance with                
#  the License.  You may obtain a copy of the License at                               
#                                                                                      
#      http://www.apache.org/licenses/LICENSE-2.0                                      
#                                                                                      
#  Unless required by applicable law or agreed to in writing, software                 
#  distributed under the License is distributed on an "AS IS" BASIS,                   
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.            
#  See the License for the specific language governing permissions and                 
#  limitations under the License.                                                      
                                                                                       
###############################################################################
# Nightly tests for pig.
#
#

#PigSetup::setup();

#my $me = `whoami`;
#chomp $me;

$cfg = {
	'driver' => 'Pig',
	'nummachines' => 5,

	'groups' => [
		{
		'name' => 'Checkin',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
store a into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k;",
			'floatpostprocess' => 1,
			'delimiter' => '	',
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 50;
d = filter b by age < 50;
e = cogroup c by (name, age), d by (name, age) ;
f = foreach e generate flatten(c), flatten(d);
g = group f by registration;
h = foreach g generate group, SUM(f.d::contributions);
i = order h by $1;
store i into ':OUTPATH:';\,
			'sql' => "select registration, sum(contributions)
from studenttab10k as a full outer join votertab10k as b using (name, age)
where a.age < 50 and b.age < 50
group by registration
order by 2;",
			'floatpostprocess' => 1,
			'delimiter' => '	',
			'sortArgs' => ['-t', '	', '+1', '-2'],
			}
		]
		},
		{
		'name' => 'LoaderDefaultDir',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/dir/studenttab10k' as (name, age, gpa);
store a into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k;",
			},
		]
		},
		{
		'name' => 'LoaderPigStorageArg',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studentcolon10k' using PigStorage(':') as (name, age, gpa);
store a into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studentcolon10k;",
			},
			{
			# load with control character
			'num' => 2,
			'pig' => q#a = load ':INPATH:/singlefile/studentctrla10k' using PigStorage('\\u0001') as (name, age, gpa);
store a into ':OUTPATH:';#,
			'sql' => "select name, age, gpa from studentctrla10k;",
			},
			{
	        	# load and store with control character
			'num' => 3,
			'pig' => q#a = load ':INPATH:/singlefile/studentctrla10k' using PigStorage('\\u0001') as (name, age, gpa);
store a into ':OUTPATH:.intermediate' using PigStorage('\\u0001');
b = load ':OUTPATH:.intermediate' using PigStorage('\\u0001') as (name, age, gpa); 
store b into ':OUTPATH:'; #,
			'sql' => "select name, age, gpa from studentctrla10k;",
			},
		]
		},
		{
		# Results doctored, if you change this query you need to copy the
		# expected results into test/nightly/benchmarks
		'name' => 'LoaderBinStorage',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate name, org.apache.pig.test.udf.evalfunc.Swap(name, age), TOKENIZE((chararray)name), org.apache.pig.test.udf.evalfunc.CreateMap((chararray)name, age); 
store b into ':OUTPATH:.intermediate' using BinStorage();
c = load ':OUTPATH:.intermediate' using BinStorage();
store c into ':OUTPATH:' using org.apache.pig.test.udf.storefunc.StringStore();\,
			'sql' => "select name, age, gpa from studenttab10k;",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
		]
		},
		{
		# Results doctored, if you change this query you need to copy the
		# expected results into test/nightly/benchmarks
		'name' => 'LoaderTextLoader',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/textdoc' using TextLoader();
b = foreach a generate TOKENIZE((chararray)$0);
store b into ':OUTPATH:' using org.apache.pig.test.udf.storefunc.StringStore();\,
			'sql' => "select name from textdoc;",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
		]
		},
		{
		'name' => 'FilterBoolean',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by name == 'fred allen' and age > 50;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name = 'fred allen' and age > 50;",
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/dir/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by name != 'fred allen' or age < 10;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name != 'fred allen' or age < 10;",
			},
			{
			'num' => 3,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by not (age == 50);
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where age != 50;",
			},
			{
			'num' => 4,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by (age >= 50 or name > 'fred') and (gpa <= 3.0 or name >= 'bob');
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where (age >= 50 or name > 'fred') and (gpa <= 3.0 or name >= 'bob');",
			},
			{
			'num' => 5,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by age >= 50 or name > 'fred' and gpa <= 3.0 or name >= 'bob';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where age >= 50 or name > 'fred' and gpa <= 3.0 or name >= 'bob';",
			},
            # test filter <= and >= for chararray, int and double
			{
			'num' => 6,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa:double);
b = filter a by age >= 40 and age <=50 and gpa >= 2.0 and gpa <= 3.0 and  name >= 'bob' and name <= 'fred';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where age >= 40 and age <=50 and gpa >= 2.0 and gpa <= 3.0 and  name >= 'bob' and name <= 'fred';"
			},
            # test filter <= and >= for bytearray, long and float
			{
			'num' => 7,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age:long, gpa:float);
b = filter a by age >= 40 and age <=50 and gpa >= 2.0f and gpa <= 3.0f and  name >= 'bob' and name <= 'fred';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where age >= 40 and age <=50 and gpa >= 2.0 and gpa <= 3.0 and  name >= 'bob' and name <= 'fred';"
			},
            # test filter < and > for chararray, int and double
			{
			'num' => 8,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa:double);
b = filter a by age > 40 and age <50 and gpa > 2.0 and gpa < 3.0 and  name > 'bob' and name < 'fred';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where age > 40 and age <50 and gpa > 2.0 and gpa < 3.0 and  name > 'bob' and name < 'fred';"
			},
            # test filter < and > for bytearray, long and float
			{
			'num' => 9,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age:long, gpa:float);
b = filter a by age > 40 and age <50 and gpa > 2.0f and gpa < 3.0f and  name > 'bob' and name < 'fred';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where age > 40 and age <50 and gpa > 2.0 and gpa < 3.0 and  name > 'bob' and name < 'fred';"
			},
            # test filter <= and >= for explicit cast for chararray, int and double
			{
			'num' => 10,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by (int)age >= 40 and (int)age <=50 and (double)gpa >= 2.0 and (double)gpa <= 3.0 and  (chararray)name >= 'bob' and (chararray)name <= 'fred';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where age >= 40 and age <=50 and gpa >= 2.0 and gpa <= 3.0 and  name >= 'bob' and name <= 'fred';"
			},
            # test filter <= and >= for explicit cast for bytearray, long and float
			{
			'num' => 11,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by (long)age >= 40 and (long)age <=50 and (float)gpa >= 2.0f and (float)gpa <= 3.0f and  name >= 'bob' and name <= 'fred';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where age >= 40 and age <=50 and gpa >= 2.0 and gpa <= 3.0 and  name >= 'bob' and name <= 'fred';"
			},
            # test filter < and > for explicit cast for chararray, int and double
			{
			'num' => 12,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by (int)age > 40 and (int)age <50 and (double)gpa > 2.0 and (double)gpa < 3.0 and  (chararray)name > 'bob' and (chararray)name < 'fred';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where age > 40 and age <50 and gpa > 2.0 and gpa < 3.0 and  name > 'bob' and name < 'fred';"
			},
            # test filter < and > for explicit cast for bytearray, long and float
			{
			'num' => 13,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by (long)age > 40 and (long)age <50 and (float)gpa > 2.0f and (float)gpa < 3.0f and  name > 'bob' and name < 'fred';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where age > 40 and age <50 and gpa > 2.0 and gpa < 3.0 and  name > 'bob' and name < 'fred';"
			},
            # test AND with nulls
			{
			'num' => 14,
			'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' using PigStorage() as (name, age, gpa);
b = filter a by name == 'fred allen' and age > 50;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studentnulltab10k
where name = 'fred allen' and age > 50;",
			},
            # test OR with nulls
			{
			'num' => 15,
			'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' using PigStorage() as (name, age, gpa);
b = filter a by name != 'fred allen' or age < 10;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studentnulltab10k
where name != 'fred allen' or age < 10;",
			},
            # test with nulls filter <= and >= for chararray, int and double
			{
			'num' => 16,
			'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' using PigStorage() as (name:chararray, age:int, gpa:double);
b = filter a by age >= 40 and age <=50 and gpa >= 2.0 and gpa <= 3.0 and  name >= 'bob' and name <= 'fred';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studentnulltab10k
where age >= 40 and age <=50 and gpa >= 2.0 and gpa <= 3.0 and  name >= 'bob' and name <= 'fred';"
			},
            # test with nulls filter < and > for explicit cast for chararray, int and double
			{
			'num' => 17,
			'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' using PigStorage() as (name, age, gpa);
b = filter a by (int)age > 40 and (int)age <50 and (double)gpa > 2.0 and (double)gpa < 3.0 and  (chararray)name > 'bob' and (chararray)name < 'fred';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studentnulltab10k
where age > 40 and age <50 and gpa > 2.0 and gpa < 3.0 and  name > 'bob' and name < 'fred';"
			},
		],
		},
		{
		'name' => 'FilterEq',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by name == 'alice johnson' and age == 64 and gpa == 3.99;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name = 'alice johnson' and age = 64 and gpa >= 3.99;", # I know this doesn't match the query above, but for whatever weird reason when you say gpa = 3.99 in postgres it doesn't match.  
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by name > 'fred allen' and age > 40 and gpa > 2.50;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name > 'fred allen' and age > 40 and gpa > 2.50;",
			},
			{
			'num' => 3,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by name >= 'fred allen' and age >= 40 and gpa >= 2.50;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name >= 'fred allen' and age >= 40 and gpa >= 2.50;",
			},
			{
			'num' => 4,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by name lt 'fred allen' and age < 40 and gpa < 2.50;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name < 'fred allen' and age < 40 and gpa < 2.50;",
			},
			{
			'num' => 5,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by name lte 'fred allen' and age <= 40 and gpa <= 2.50;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name <= 'fred allen' and age <= 40 and gpa <= 2.50;",
			},
			{
			'num' => 6,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage();
b = filter a by $0 neq 'fred allen' and $1 != '40' and $2 != '2.50';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name != 'fred allen' and age != 40 and gpa != 2.50;",
			},
            # test for filter == for chararray, int and double
			{
			'num' => 7,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa:double);
b = filter a by  name == 'fred allen' and age == 61 and gpa == 1.42;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name = 'fred allen' and age = 61 and cast(gpa as numeric) = 1.42;",
			},
            # test for filter == for bytearray, long and float
			{
			'num' => 8,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age:long, gpa:float);
b = filter a by  name == 'fred allen' and age == 61 and gpa == 1.42f;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name = 'fred allen' and age = 61 and cast(gpa as numeric) = 1.42;",
			},
            # test for filter != for chararray, int and double
			{
			'num' => 9,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa:double);
b = filter a by $0 != 'fred allen' and $1 != 40 and $2 != 2.50;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name != 'fred allen' and age != 40 and gpa != 2.50;",
			},
            # test for filter != for bytearray, long and float
			{
			'num' => 10,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age:long, gpa:float);
b = filter a by $0 != 'fred allen' and $1 != 40 and $2 != 2.50f;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name != 'fred allen' and age != 40 and gpa != 2.50;",
			},
            # test for filter == for explicit casts to chararray, int and double
			{
			'num' => 11,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by  (chararray)name == 'fred allen' and (int)age == 61 and (double)gpa == 1.42;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name = 'fred allen' and age = 61 and cast(gpa as numeric) = 1.42;",
			},
            # test for filter == for explicit casts to bytearray, long and float
			{
			'num' => 12,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by  name == 'fred allen' and (long)age == 61 and (float)gpa == 1.42f;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name = 'fred allen' and age = 61 and cast(gpa as numeric) = 1.42;",
			},
            # test for filter != for explicit casts to chararray, int and double
			{
			'num' => 13,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() ;
b = filter a by (chararray)$0 != 'fred allen' and (int)$1 != 40 and (double)$2 != 2.50;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name != 'fred allen' and age != 40 and gpa != 2.50;",
			},
            # test for filter != for explicit casts to bytearray, long and float
			{
			'num' => 14,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() ;
b = filter a by $0 != 'fred allen' and (long)$1 != 40 and (float)$2 != 2.50f;
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name != 'fred allen' and age != 40 and gpa != 2.50;",
			},
		]
		},
		{
		'name' => 'FilterMatches',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = filter a by name matches '^fred.*';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name like 'fred%';",
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage();
b = filter a by not $0 matches '^fred.*';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, gpa
from studenttab10k
where name not like 'fred%';",
			},
			{
            # test for filter on matches for chararray (declared and explicit cast)
			'num' => 3,
			'pig' => q\a = load ':INPATH:/singlefile/votertab10k' using PigStorage() as (name:chararray, age:int, registration, contributions:double);
b = filter a by name matches '^fred.*' and (chararray)registration matches '^dem.*';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, registration, contributions
from votertab10k
where name like 'fred%' and registration like 'dem%';",
			},
			{
			'num' => 4,
			'pig' => q\a = load ':INPATH:/singlefile/votertab10k' using PigStorage() as (name:chararray, age:int, registration, contributions:double);
b = filter a by name matches 'f.ed' and (chararray)registration matches 'd.m';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, registration, contributions
from votertab10k
where name like 'f_ed' and registration like 'd_m';",
			},
			{
			'num' => 5,
			'pig' => q\a = load ':INPATH:/singlefile/votertab10k' using PigStorage() as (name:chararray, age:int, registration, contributions:double);
b = filter a by name matches 'f[^f]ed.*';
store b into ':OUTPATH:' using PigStorage;\,
			'sql' => "select name, age, registration, contributions
from votertab10k
where name ~ 'f[^f]ed.*';",
			},
			{
			'num' => 6,
			'pig' => "a = load ':INPATH:/singlefile/votertab10k' using PigStorage() as (name:chararray, age:int, registration, contributions:double);\nb = filter a by name matches '.*\\\\wan.*';\nstore b into ':OUTPATH:' using PigStorage;",
			'sql' => "select name, age, registration, contributions from votertab10k where name ~ '.*\\\\wan.*';",
			},
			{
			'num' => 7,
			'pig' => "a = load ':INPATH:/singlefile/votertab10k' using PigStorage() as (name:chararray, age:int, registration, contributions:double);\nb = filter a by name matches '^e.*\\\\sc.*';\nstore b into ':OUTPATH:' using PigStorage;",
			'sql' => "select name, age, registration, contributions from votertab10k where name ~ '^e.*\\\\sc.*';",
			},
			{
			'num' => 8,
			'pig' => "a = load ':INPATH:/singlefile/votertab10k' using PigStorage() as (name:chararray, age:int, registration, contributions:double);\nb = filter a by name matches 'ethan white';\nstore b into ':OUTPATH:' using PigStorage;",
			'sql' => "select name, age, registration, contributions from votertab10k where name ~ 'ethan white';",
			},
			{
			'num' => 9,
			'pig' => "a = load ':INPATH:/singlefile/studentnulltab10k' using PigStorage() as (name, age, gpa);\nb = filter a by gpa matches '\\\\d\\\\.45';\nstore b into ':OUTPATH:' using PigStorage;",
			'sql' => "select name, age, gpa from studentnulltab10k where gpa ~ '\\\\d\\\\.45';",
			},
		]
		},
		{
		'name' => 'FilterUdf',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = cogroup a by (name, age), b by (name, age);
d = filter c by not IsEmpty(a);
e = filter d by not IsEmpty(b);
f = foreach e generate flatten(a), flatten(b);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, registration, contributions
from studenttab10k as a join votertab10k as b using (name, age);",
			},
		]
		},
		# TODO Group that don't flatten via Agg functions
		{
		'name' => 'GroupAggFunc',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, COUNT(a.age);
store c into ':OUTPATH:';\,
			'sql' => "select name, count(age) from studenttab10k group by name;",
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = group a by $0;
c = foreach b generate group, COUNT(a.$1);
store c into ':OUTPATH:';\,
			'sql' => "select name, count(age) from studenttab10k group by name;",
			},
			{
			'num' => 3,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by (name, age);
c = foreach b generate group.name, group.age, COUNT(a.gpa);
store c into ':OUTPATH:';\,
			'sql' => "select name, age, count(gpa) from studenttab10k group by name, age;",
			},
			{
			'num' => 5,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a all;
c = foreach b generate COUNT(a.$0);
store c into ':OUTPATH:';\,
			'sql' => "select count(*) from studenttab10k;",
			},
			{
			'num' => 6,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, SUM(a.age);
store c into ':OUTPATH:';\,
			'sql' => "select name, sum(age)
from studenttab10k
group by name;",
			'floatpostprocess' => 1,
			'delimiter' => '	',
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
			{
			'num' => 7,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, SUM(a.gpa);
store c into ':OUTPATH:';\,
			'sql' => "select name, sum(gpa)
from studenttab10k
group by name;",
			'floatpostprocess' => 1,
			'delimiter' => '	',
			},
			{
			'num' => 8,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, AVG(a.age);
store c into ':OUTPATH:';\,
			'sql' => "select name, avg(age)
from studenttab10k
group by name;",
			'floatpostprocess' => 1,
			'delimiter' => '	',
			},
			{
			'num' => 9,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, AVG(a.gpa);
store c into ':OUTPATH:';\,
			'sql' => "select name, avg(gpa)
from studenttab10k
group by name;",
			'floatpostprocess' => 1,
			'delimiter' => '	',
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
			{
			'num' => 10,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, MIN(a.gpa);
store c into ':OUTPATH:';\,
			'sql' => "select name, min(gpa)
from studenttab10k
group by name;",
			'floatpostprocess' => 1,
			'delimiter' => '	',
			},
			{
			'num' => 11,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, MAX(a.gpa);
store c into ':OUTPATH:';\,
			'sql' => "select name, max(gpa)
from studenttab10k
group by name;",
			'floatpostprocess' => 1,
			'delimiter' => '	',
			},
            {
			'num' => 12,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by (name, age);
c = foreach b generate flatten(group), SUM(a.gpa);
store c into ':OUTPATH:';\,
			'sql' => "select name, age, sum(gpa)
from studenttab10k
group by name, age;",
			'floatpostprocess' => 1,
			'delimiter' => '	',
			},
            {
			'num' => 13,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by (name);
c = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
d = cogroup b by group, c by name;
e = foreach d generate flatten(group), SUM(c.gpa), COUNT(c.name);
store e into ':OUTPATH:';\,
			'sql' => "select name, sum(gpa), count(name)
from studenttab10k
group by name;",
			'floatpostprocess' => 1,
			'delimiter' => '	',
			}
			],
		},
		{
		'name' => 'EvalFunc',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = filter a by name lt 'b';
c = foreach b generate ARITY(name, age, gpa);
store c into ':OUTPATH:';\,
			'sql' => "select 3 from studenttab10k where name < 'b';",
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age, gpa);
b = filter a by name lt 'b';
c = foreach b generate TOKENIZE(name);
d = foreach c generate flatten($0);
store d into ':OUTPATH:';\,
			'sql' => "select name from studenttab10k;",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
			{
			'num' => 3,
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = filter a by name lt 'b';
c = foreach b generate org.apache.pig.test.udf.evalfunc.Swap(name, age);
store c into ':OUTPATH:' using org.apache.pig.test.udf.storefunc.StringStore();\,
			'sql' => "select age, name from studenttab10k where name < 'b';",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
			{
			'num' => 4,
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = filter a by name lt 'b';
c = foreach b generate org.apache.pig.test.udf.evalfunc.CreateMap((chararray)name, age);
store c into ':OUTPATH:' using org.apache.pig.test.udf.storefunc.StringStore();\,
			'sql' => "select name, age from studenttab10k where name < 'b';",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			}
		]
		},
		# TODO DIFF
		# TODO User defined grouping function
		{
		'name' => 'CoGroupFlatten',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 20;
d = filter b by age < 20;
e = cogroup c by name, d by name;
f = foreach e generate flatten (c), flatten(d);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a full outer join votertab10k as b using(name)
where a.age < 20 and b.age < 20;",
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by $1 < 20;
d = filter b by $1 < 20;
e = cogroup c by $0, d by $0;
f = foreach e generate flatten (c), flatten(d);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a full outer join votertab10k as b using(name)
where a.age < 20 and b.age < 20;",
			},
			{
			'num' => 3,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 20;
d = filter b by age < 20;
e = cogroup c by (name, age), d by (name, age);
f = foreach e generate flatten (c), flatten(d);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a full outer join votertab10k as b using(name, age)
where a.age < 20 and b.age < 20;",
			},
			{
			'num' => 4,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
d = filter b by age < 20;
e = cogroup a by (name, age) inner, d by (name, age);
f = foreach e generate flatten (a), flatten(d);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a right outer join votertab10k as b using(name, age)
where a.age < 20;",
			},
			{
			'num' => 5,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 20;
e = cogroup c by (name, age), b by (name, age) inner;
f = foreach e generate flatten (c), flatten(b);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a left outer join votertab10k as b using(name, age)
where b.age < 20;",
			},
			{
			'num' => 6,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
e = cogroup a by (name, age) inner, b by (name, age) inner;
f = foreach e generate flatten (a), flatten(b);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a join votertab10k as b using(name, age);",
			},
            {
            # Test cogrouping data loaded from two separate loaders.  We don't have any data that can join with studenttab that isn't also loaded with PigStorage, so the
            # first step is an intermediate load and store using BinStorage.
    		'num' => 7,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
store a into ':OUTPATH:.intermediate' using BinStorage();
b = load ':OUTPATH:.intermediate' using BinStorage() as (name, age, gpa);
c = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
e = cogroup b by (name, age) inner, c by (name, age) inner;
f = foreach e generate flatten (b), flatten(c);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a join votertab10k as b using(name, age);",
            },
            
		]
		},
		{
		'name' => 'CoGroup',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = cogroup a by name, b by name;
d = foreach c generate flatten(group), COUNT(a) + COUNT(b);
store d into ':OUTPATH:';\,
			'sql' => "select a.name, b.name, count(*)
from studenttab10k as a full outer join votertab10k as b using(name)
group by a.name, b.name;",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
		]
		},
		{
		'name' => 'Join',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 20;
d = filter b by age < 20;
e = join c by name, d by name;
store e into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a join votertab10k as b using(name)
where a.age < 20 and b.age < 20;",
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 20;
d = filter b by age < 20;
e = join c by $0, d by $0;
store e into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a join votertab10k as b using(name)
where a.age < 20 and b.age < 20;",
			},
			{
			'num' => 3,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 20;
d = filter b by age < 20;
e = join c by (name, age), d by (name, age);
store e into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a join votertab10k as b using(name, age)
where a.age < 20 and b.age < 20;",
			},
            # self join with implict split
            # JIRA PIG-429
			{
			'num' => 4,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = filter a by $1 > 25;
c = join a by $0, b by $0;
store c into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.gpa
from studenttab10k as a join studenttab10k as b using(name)
where b.age > 25;",
			},
            # join with one input having schema and another without
            # JIRA PIG-428
			{
			'num' => 5,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray,age:int, gpa:double);
another = load ':INPATH:/singlefile/studenttab10k';
c = foreach another generate $0, $1+ 10, $2 + 10.0;
d = join a by $0, c by $0;
store d into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age + 10, b.gpa + 10.0
from studenttab10k as a join studenttab10k as b using(name);",
			},
            # self join using fragment replicate join
            # no types
			{
			'num' => 6,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
c = join a by name, b by name using 'repl';
store c into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.gpa
from studenttab10k as a join studenttab10k as b using(name);",
			},
            # self join using fragment replicate join
            # with types and no cast for join key
			{
			'num' => 7,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:double);
b = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:double);
c = join a by name, b by name using 'repl';
store c into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.gpa
from studenttab10k as a join studenttab10k as b using(name);",
			},
            # self join using fragment replicate join
            # with types and cast for join key
			{
			'num' => 8,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:double);
b = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa);
c = join a by gpa, b by gpa using 'repl';
store c into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.gpa
from studenttab10k as a join studenttab10k as b using(gpa);",
			},
            # left outer join
			{
			'num' => 9,
			'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = load ':INPATH:/singlefile/voternulltab10k' as  (name:chararray, age:long, registration:chararray, contributions:double); 
c = join a by name left outer, b by name;
store c into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studentnulltab10k as a left outer join voternulltab10k as b using(name);",
			},
            # right outer join
			{
			'num' => 10,
			'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = load ':INPATH:/singlefile/voternulltab10k' as  (name:chararray, age:long, registration:chararray, contributions:double); 
c = join a by name right outer, b by name;
store c into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studentnulltab10k as a right outer join voternulltab10k as b using(name);",
			},
            # full outer join
			{
			'num' => 11,
			'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = load ':INPATH:/singlefile/voternulltab10k' as  (name:chararray, age:long, registration:chararray, contributions:double); 
c = join a by name full outer, b by name;
store c into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studentnulltab10k as a full outer join voternulltab10k as b using(name);",
			},
            # see PIG-1209 join package now uses internalcachedBag, so every tuple on reduce side in this test will spilled to disk.
			{
			'num' => 12,
	 		'java_params' => ['-Dpig.cachedbag.memusage=0'],
			 'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
			 b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
			 c = filter a by age < 20;
			 d = filter b by age < 20;
			 e = join c by name, d by name;
			 store e into ':OUTPATH:';\,
			 'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
			 from studenttab10k as a join votertab10k as b using(name) where a.age < 20 and b.age < 20;",
			},
		]
		},
		{
		'name' => 'Foreach',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate *;
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k;",
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = foreach a generate *;
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k;",
			},
			{
			'num' => 3,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate name, age;
store b into ':OUTPATH:';\,
			'sql' => "select name, age from studenttab10k;",
			},
			{
			'num' => 4,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = foreach a generate $0, $2;
store b into ':OUTPATH:';\,
			'sql' => "select name, gpa from studenttab10k;",
			},
			{
                # test filter, projection, sort , duplicate elimination
                'num' => 5,
                'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = filter a by age < 20;
c = group b by age;
d = foreach c { 
    cf = filter b by gpa < 3.0; 
    cp = cf.gpa; 
	cd = distinct cp;
    co = order cd by $0; 
    generate group, flatten(co);
    }
store d into ':OUTPATH:';\,
                'sql' => "select distinct age, gpa from studenttab10k where age < 20 and gpa < 3.0 order by age, gpa;",
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
            },
			{
			# test flatten for map and scalar
			'num' => 6,
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate flatten(name) as n, flatten(org.apache.pig.test.udf.evalfunc.CreateMap((chararray)name, gpa)) as m;
store b into ':OUTPATH:' using org.apache.pig.test.udf.storefunc.StringStore();\,
			'sql' => "select name, age, gpa from studenttab10k;",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
			{
			# test flatten for UDF that returns bag with multiple tuples with multiple columns
			'num' => 7,
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate name, flatten(org.apache.pig.test.udf.evalfunc.CreateTupleBag(age, gpa)) as foo;
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k union all select name, gpa, age from studenttab10k;",
			'floatpostprocess' => 1,
			'delimiter' => '	',
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
			{
			'num' => 8,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age: int, gpa);
c = group a by name;
d = foreach c generate flatten(group), MAX(a.age) + MIN(a.age);
store d into ':OUTPATH:';\,
			'sql' => "select name, max(age) + min(age) from studenttab10k group by name;",
			},
			{
                # test filter, projection, sort , duplicate elimination
                'num' => 9,
                'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = filter a by age < 20;
c = group b by age;
d = foreach c { 
    cf = filter b by gpa >= 3.0 and gpa <= 3.5; 
    cp = cf.gpa; 
	cd = distinct cp;
    co = order cd by $0; 
    generate group, flatten(co);
    }
store d into ':OUTPATH:';\,
                'sql' => "select distinct age, gpa from studenttab10k where age < 20 and gpa >= 3.0 and gpa <= 3.5 order by age, gpa;",
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
            },
			{
                # test filter, projection, sort , duplicate elimination
                'num' => 10,
                'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = filter a by age < 20;
c = group b by age;
d = foreach c { 
    cf = filter b by (gpa == 4.0 or gpa != 2.0) and name > 'a'; 
    cp = cf.gpa; 
	cd = distinct cp;
    co = order cd by $0; 
    generate group, flatten(co);
    }
store d into ':OUTPATH:';\,
                'sql' => "select distinct age, gpa from studenttab10k where age < 20 and name > 'a' and (gpa = 4.0 or gpa != 2.0) order by age, gpa;"
            },
			{
                # test filter, projection, sort , duplicate elimination
                'num' => 11,
                'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = filter a by age < 20;
c = foreach b { 
    exp1 = age + gpa;
    exp2 = exp1 + age;
    generate exp1, exp2;
    }
store c into ':OUTPATH:';\,
                'sql' => "select (age + gpa), (age + gpa + age) from studenttab10k where age < 20;"
            },
			{
                # test a udf with no args
                'num' => 12,
                'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate name, org.apache.pig.test.udf.evalfunc.Fred() as fred;
store b into ':OUTPATH:';\,
                'sql' => "select name, 'fred' from studenttab10k;"
            }
		]
		},
		{
		'name' => 'Order',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate name;
c = order b by name;
store c into ':OUTPATH:';\,
			'sql' => "select name from studenttab10k order by name;",
			'sortArgs' => ['-t', '	', '+0', '-1'],
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = foreach a generate $1;
c = order b by $0;
store c into ':OUTPATH:';\,
			'sql' => "select age from studenttab10k order by age;",
			'sortArgs' => ['-t', '	', '+0', '-1'],
			},
			{
			'num' => 3,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate gpa;
c = order b by gpa;
store c into ':OUTPATH:';\,
			'sql' => "select gpa from studenttab10k order by gpa;",
			'sortArgs' => ['-t', '	', '+0', '-1'],
			},
			{
			'num' => 4,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = order a by *;
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by 1,2,3;",
			'sortArgs' => ['-t', '	'],
			},
			{
			'num' => 5,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate name, age;
c = order b by name, age;
store c into ':OUTPATH:';\,
			'sql' => "select name, age from studenttab10k order by 1,2;",
			'sortArgs' => ['-t', '	', '+0', '-2'],
			},
            {
			'num' => 6,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
c = order a by $0;
store c into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by name;",
			'sortArgs' => ['-t', '	', '+0', '-1'],
			},
            {
			'num' => 7,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
c = order a by $1;
store c into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by age;",
			'sortArgs' => ['-t', '	', '+1', '-2'],
			},
            {
			'num' => 8,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
c = order a by $0, $1;
store c into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by name, age;",
			'sortArgs' => ['-t', '	', '+0', '-2'],
			},
            {
			'num' => 9,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
c = order a by $1, $0;
store c into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by age, name;",
			'sortArgs' => ['-t', '	', '+1', '-2', '+0', '-1'],
			},
            {
			'num' => 10,
			'ignore' => 'order by UDF is not supported',
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k';
c = order a by * using org.apache.pig.test.udf.orderby.OrdDesc;
store c into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by name desc, age desc, gpa desc;",
			'sortArgs' => ['-t', '	', '-r'],
			},
            {
			'num' => 11,
			'ignore' => 'order by UDF is not supported',
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k';
c = order a by $0 using org.apache.pig.test.udf.orderby.OrdDesc;
store c into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by name desc;",
			'sortArgs' => ['-t', '	', '-r', '+0', '-1'],
			},
            {
			'num' => 12,
			'ignore' => 'order by UDF is not supported',
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k';
c = order a by $0, $1 using org.apache.pig.test.udf.orderby.OrdDesc;
store c into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by name desc, age desc;",
			'sortArgs' => ['-t', '	', '-r', '+0', '-2'],
			},
# ALERT All these tests with inner order bys aren't testing the inner
# ordering.  We need to develop a sorting tool to do that.
            {
			'num' => 13,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = group a by $0;
c = foreach b {c1 = order $1 by $1; generate flatten(c1); };
store c into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by name, age;",
			},
            {
			'num' => 14,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = group a by $0;
c = foreach b {c1 = order $1 by *; generate flatten(c1); };
store c into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by name, age, gpa;",
            # 'sortArgs' => ['-t', '	'],
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
            {
			'num' => 15,
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k';
b = group a by $0;
c = foreach b {c1 = order $1 by * using org.apache.pig.test.udf.orderby.OrdDesc; generate flatten(c1); };
store c into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by name, age desc, gpa desc;",
            #'sortArgs' => ['-t', '	', '-r'],
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
            {
			'num' => 16,
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k';
b = group a by $0;
c = foreach b {c1 = order $1 by $1 using org.apache.pig.test.udf.orderby.OrdDesc; generate flatten(c1);};
store c into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by name, age desc;",
            #'sortArgs' => ['-t', '	', '-r', '+0', '-1'],
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
            {
			'num' => 17,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = group a by $0;
c = foreach b {c1 = order $1 by $1; generate flatten(c1), MAX($1.$1); };
store c into ':OUTPATH:';\,
			# This SQL query isn't right, because you can't group by name and have
			# age in the output, like you can in Pig Latin
			'sql' => "select name, age, gpa, max(age) from studenttab10k group by name, age, gpa order by age;",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
            {
            # test to make sure the weighted range patitioning
            # works correctly when a sort key value repeats across
            # reduce partitions
			'num' => 18,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = order a by $1 parallel 100;
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k order by age;",
			'sortArgs' => ['-t', '	', '+1', '-2'],
			},
		]
		},
		{
		'name' => 'Distinct',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate name;
c = distinct b;
store c into ':OUTPATH:';\,
			'sql' => "select distinct name from studenttab10k ;",
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = foreach a generate $1;
c = distinct b;
store c into ':OUTPATH:';\,
			'sql' => "select distinct age from studenttab10k ;",
			},
			{
			'num' => 3,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate gpa;
c = distinct b;
store c into ':OUTPATH:';\,
			'sql' => "select distinct gpa from studenttab10k;",
			},
			{
			'num' => 4,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = distinct a;
store b into ':OUTPATH:';\,
			'sql' => "select distinct name, age, gpa from studenttab10k;",
			},
			{
			'num' => 5,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate name, age;
c = distinct b;
store c into ':OUTPATH:';\,
			'sql' => "select distinct name, age from studenttab10k;",
			},
			{
			'num' => 6,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b { aa = distinct a.age; generate group, COUNT(aa); }
store c into ':OUTPATH:';\,
			'sql' => "select name, count(distinct age) from studenttab10k group by name;",
			}
		]
		},
		{
		'name' => 'Cross',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 19 and gpa < 1.0;
d = filter b by age < 19;
e = cross c, d;
store e into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a cross join votertab10k as b
where a.age < 19 and b.age < 19 and a.gpa < 1.0;"
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 19 and gpa < 1.0;
d = filter b by age < 19;
e = cross c, d parallel 10;
store e into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a cross join votertab10k as b
where a.age < 19 and b.age < 19 and a.gpa < 1.0;"
			},
			{
			'num' => 3,
			'pig' => q\set default_parallel 10;
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 19 and gpa < 1.0;
d = filter b by age < 19;
e = cross c, d;
store e into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a cross join votertab10k as b
where a.age < 19 and b.age < 19 and a.gpa < 1.0;"
			},
			{
			'num' => 4,
			'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 25;
d = filter b by age < 25;
e = cross c, d;
f = filter e by c::age < d::age;
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a, votertab10k as b
where a.age < 25 and b.age < 25 and a.age < b.age;"
			}
		]
		},
		{
		'name' => 'Union',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = foreach a generate name, age;
d = foreach b generate name, age;
e = union c, d;
store e into ':OUTPATH:';\,
			'sql' => "select name, age from studenttab10k
union all
select name, age from votertab10k;",
			},
		]
		},
		{
		'name' => 'Bincond',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = foreach a generate name, (name matches 'yuri.*' ? age - 10 : (int)age);
store b into ':OUTPATH:';\,
			'sql' => "select name, case when name like 'yuri%' then age - 10 else age end from studenttab10k;",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
		]
		},
		{
		'name' => 'Glob',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10?' as (name, age, gpa);
b = filter a by name == 'nick miller';
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k where name = 'nick miller';",
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/st*ttab10k' as (name, age, gpa);
b = filter a by name == 'nick miller';
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k where name = 'nick miller';",
			},
			{
			'num' => 3,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab*' as (name, age, gpa);
b = filter a by name == 'nick miller';
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k where name = 'nick miller'
union all
select name, age, gpa from studenttab20m where name = 'nick miller';",
			},
			{
			'num' => 4,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab???' as (name, age, gpa);
b = filter a by name == 'nick miller';
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k where name = 'nick miller'
union all
select name, age, gpa from studenttab20m where name = 'nick miller';",
			},
			{
			'num' => 5,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab[1-9]0[km]' as (name, age, gpa);
b = filter a by name == 'nick miller';
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k where name = 'nick miller'
union all
select name, age, gpa from studenttab20m where name = 'nick miller';",
			},
			{
			'num' => 6,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab[13]0[km]' as (name, age, gpa);
b = filter a by name == 'nick miller';
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k where name = 'nick miller';",
			},
			{
			'num' => 7,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab[12]0[a-l]' as (name, age, gpa);
b = filter a by name == 'nick miller';
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttab10k where name = 'nick miller';",
			},
			{
			'num' => 8,
			'pig' => q\a = load ':INPATH:/glob/star/*good' as (name, age, gpa);
b = filter a by name == 'nick miller';
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttabsomegood where name = 'nick miller'
union all
select name, age, gpa from studenttabmoregood where name = 'nick miller';",
			},
			{
			'num' => 9,
			'pig' => q\a = load ':INPATH:/glob/star/*' as (name, age, gpa);
b = filter a by name == 'nick miller';
store b into ':OUTPATH:';\,
			'sql' => "select name, age, gpa from studenttabsomegood where name = 'nick miller'
union all
select name, age, gpa from studenttabmoregood where name = 'nick miller'
union all
select name, age, gpa from studenttabbad where name = 'nick miller';",
			}
		]
		},
		{
		'name' => 'Arithmetic',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
c = foreach a generate age + 1, (int)gpa + 1;
store c into ':OUTPATH:';\,
			'sql' => "select age + 1, floor(gpa) + 1 from studenttab10k;",
			},
			{
			'num' => 2,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
c = foreach a generate (double)age + 1.5, gpa + 1.5;
store c into ':OUTPATH:';\,
			'sql' => "select age + 1.5, gpa + 1.5 from studenttab10k;",
			},
			{
			'num' => 3,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
c = foreach a generate age - 30, (int)gpa - 3;
store c into ':OUTPATH:';\,
			'sql' => "select age - 30, floor(gpa) - 3 from studenttab10k;",
			},
			{
			'num' => 4,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
c = foreach a generate (double)age - 30.1, gpa - 3.199;
store c into ':OUTPATH:';\,
			'sql' => "select age - 30.1, gpa - 3.199 from studenttab10k;",
			},
			{
			'num' => 5,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
c = foreach a generate age * 10, (int)gpa * 2;
store c into ':OUTPATH:';\,
			'sql' => "select age * 10, floor(gpa) * 2 from studenttab10k;",
			},
			{
			'num' => 6,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
c = foreach a generate (double)age * 10.1, gpa * 2.752342;
store c into ':OUTPATH:';\,
			'sql' => "select age * 10.1, gpa * 2.752342 from studenttab10k;",
			},
			{
			'num' => 7,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
c = foreach a generate age  / 30, (int)gpa / 3;
store c into ':OUTPATH:';\,
			'sql' => "select floor(cast (age as float) / 30), floor(gpa / 3) from studenttab10k;",
			},
			{
			'num' => 8,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
c = foreach a generate (double)age / 30.323, gpa / 3.22;
store c into ':OUTPATH:';\,
			'sql' => "select age / 30.323, gpa / 3.22 from studenttab10k;",
			},
			{
			'num' => 9,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
c = foreach a generate 3 * age + gpa / 9.1 - 2;
store c into ':OUTPATH:';\,
			'sql' => "select 3 * age + gpa / 9.1 - 2 from studenttab10k;",
			},
			{
			'num' => 10,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
c = foreach a generate 3 * (age + gpa) / (9.1 - 2);
store c into ':OUTPATH:';\,
			'sql' => "select 3 * (age + gpa) / (9.1 - 2) from studenttab10k;",
			}
		]
		},
		{
		'name' => 'Regression',
		'tests' => [
#			{
#			'num' => 1482458,
#			'pig' => q\a = load ':INPATH:/singlefile/smallblock_studenttab10k';
#b = group a all;
#c = foreach b generate COUNT(a.$0);
#store c into ':OUTPATH:';\,
#			'sql' => "select count(*) from studenttab10k;",
#			},
			{
			'num' => 1459894,
			'pig' => q\a = load ':INPATH:/singlefile/reg1459894';
b = group a by $0;
c = foreach b generate group, COUNT(a.$1);
store c into ':OUTPATH:';\,
			'sql' => "select first, count(*) from reg1459894 group by first;",
			},
            {
			'num' => 97,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
e = cogroup a by name, b by name;
f = foreach e generate group, COUNT(a), COUNT(b);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.cnt, b.cnt
from 
    (select name, count(*) as cnt
        from studenttab10k
        group by name) as a,
    (select name, count(*) as cnt
        from votertab10k
        group by name) as b
where a.name = b.name;",
			},
            {
			'num' => 203,
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = group a by name;
c = foreach b generate group, COUNT($1);
store c into ':OUTPATH:';
--This is a really long script to test that when script size exceeds 1k we can still parse it.
--The quick sly fox jumped over the lazy brown dog.
--he quick sly fox jumped over the lazy brown dog.T
--e quick sly fox jumped over the lazy brown dog.Th
-- quick sly fox jumped over the lazy brown dog.The
--quick sly fox jumped over the lazy brown dog.The 
--uick sly fox jumped over the lazy brown dog.The q
--ick sly fox jumped over the lazy brown dog.The qu
--ck sly fox jumped over the lazy brown dog.The qui
--k sly fox jumped over the lazy brown dog.The quic
-- sly fox jumped over the lazy brown dog.The quick
--sly fox jumped over the lazy brown dog.The quick 
--ly fox jumped over the lazy brown dog.The quick s
--y fox jumped over the lazy brown dog.The quick sl
-- fox jumped over the lazy brown dog.The quick sly
--fox jumped over the lazy brown dog.The quick sly 
--ox jumped over the lazy brown dog.The quick sly f
--x jumped over the lazy brown dog.The quick sly fo
-- jumped over the lazy brown dog.The quick sly fox
--jumped over the lazy brown dog.The quick sly fox 
--umped over the lazy brown dog.The quick sly fox j
--mped over the lazy brown dog.The quick sly fox ju
--ped over the lazy brown dog.The quick sly fox jum\,
			'sql' => "select name, count(*)
from studenttab10k
group by name;",
			}
		]
		},
        {
		'name' => 'Unicode',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\a = load ':INPATH:/singlefile/unicode100';
store a into ':OUTPATH:';\,
			'sql' => "select name from unicode100;",
			},
		]
		},
		{
		'name' => 'Parameters',
		'tests' => [
			{
				# test default
				'num' => 1,
				'pig' => q\%default fname 'studenttab10k'
a = load ':INPATH:/singlefile/$fname' using PigStorage() as (name, age, gpa);
b = foreach a generate name;
store b into ':OUTPATH:';\,
				'sql' => "select name from studenttab10k;"
			},
			{
				# test paramter from command line
				'num' => 2,
				'pig_params' => ['-p', qq(fname='studenttab10k')],
				'pig' => q\a = load ':INPATH:/singlefile/$fname' using PigStorage() as (name, age, gpa);
b = foreach a generate name;
store b into ':OUTPATH:';\,
                'sql' => "select name from studenttab10k;"
			},
			{
				# test paramter from param file
				'num' => 3,
				'pig_params' => ['-m', ":PARAMPATH:/params_3"],
				'pig' => q\a = load ':INPATH:/singlefile/$fname' using PigStorage() as (name, age, gpa);
b = foreach a generate name;
store b into ':OUTPATH:';\,
                'sql' => "select name from studenttab10k;"
			},
			{
				# test command
				'num' => 4,
				'pig' => q\%declare cmd `/usr/local/bin/perl -e 'print "studenttab10k"'`
a = load ':INPATH:/singlefile/$cmd' using PigStorage() as (name, age, gpa);
b = foreach a generate name;
store b into ':OUTPATH:';\,
                'sql' => "select name from studenttab10k;"
			},
		]
		},

		{
		'name' => 'Types',
		'sortBenchmark' => 1,
		'sortResults' => 1,
		'tests' => [
			{
				#  constants
				'num' => 1,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = foreach a generate age + 1 + 0.2f + 253645L, gpa+1;
store b into ':OUTPATH:';\,
				'sql' => "select age + 1 + cast(0.2 as float) + 253645, gpa + 1 from studentnulltab10k;"
			},
 			{
				#  NULL and cast
				'num' => 2,
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = foreach a generate (int)((int)gpa/((int)gpa - 1)) as norm_gpa:int;
c = foreach b generate (norm_gpa is null? 0 :norm_gpa);
store c into ':OUTPATH:';\,
				'sql' => "select case when (cast(gpa as integer) - 1 = 0 or gpa is null) then 0 else  cast ((cast(gpa as integer)/(cast(gpa as integer) - 1)) as integer) end from studentnulltab10k;",
			     #  'expected_err_regex' => "Encountered Warning DIVIDE_BY_ZERO 2387 time.*",
			     #  Driver does currently not support both 'sql' and 'expected_...' verification directives.
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
			},
			{
				#  arithmetic operators and SIZE for int, double and size and concat operators for chararrays
				'num' => 3,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = foreach a generate age, gpa, age % 25, age + 25, age - 25, age/2, age * 2, SIZE(age), gpa + 10.1, gpa - 1.1 , gpa / 1.2, gpa * 2.5, SIZE(gpa), SIZE(name), CONCAT(name, 'test');
store b into ':OUTPATH:';\,
				'sql' => "select age, gpa, age % 25, age + 25, age - 25, age/2, age * 2, case when age is null then null else 1 end, gpa + 10.1, gpa - 1.1 , gpa / 1.2, gpa * 2.5, case when gpa is null then null else 1 end, char_length(name), name || 'test' from studentnulltab10k;",
			},
			{
				#  arithmetic operators and SIZE for long, float and size and concat operators for bytearrays
				'num' => 4,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name, age:long, gpa:float);
b = foreach a generate age, gpa, age % 2L, age + 2500000000L, age - 2500000000L, age/2L, age * 250000000L, SIZE(age), gpa + 10.1f, gpa - 1.1f , gpa / 1.2f, gpa * 2.6f, SIZE(gpa), SIZE(name), CONCAT(name, name);
store b into ':OUTPATH:';\,
				'sql' => "select age, gpa, age % 2, age + 2500000000, age - 2500000000, age/2, cast((age * (cast(250000000 as bigint))) as bigint), case when age is null then null else 1 end, gpa + 10.1, gpa - 1.1 , gpa / 1.2, gpa * 2.6, case when gpa is null then null else 1 end, char_length(name), name || name from studentnulltab10k;",
			},
			{
				#  equlity and implicit cast
				'num' => 5,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name, age, gpa);
b = filter a by age == '25' and gpa < 3; 
store b into ':OUTPATH:';\,
				'sql' => "select * from studentnulltab10k where age = 25 and gpa < 3.0;",

			},
			{
                # will need to test against previous version of pig 
                # because in pig currently count includes nulls - this affects
                # avg
				'num' => 6,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = group a ALL;
c = foreach b generate SUM(a.age), MIN(a.age), MAX(a.age), AVG(a.age), MIN(a.name), MAX(a.name), SUM(a.gpa), MIN(a.gpa), MAX(a.gpa), AVG(a.gpa);
store c into ':OUTPATH:';\,
				'sql' => "select sum(age), min(age), max(age), avg(age), min(name), max(name), sum(gpa), min(gpa), max(gpa), avg(gpa) from studentnulltab10k;",
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',

			},
			{
				#  sum, min, max, avg for long and float (declared)
				'num' => 7,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name, age:long, gpa:float);
b = group a ALL;
c = foreach b generate SUM(a.age), MIN(a.age), MAX(a.age), AVG(a.age), SUM(a.gpa), MIN(a.gpa), MAX(a.gpa), AVG(a.gpa);
store c into ':OUTPATH:';\,
				'sql' => "select sum(age), min(age), max(age), avg(age), sum(gpa), min(gpa), max(gpa), avg(gpa) from studentnulltab10k;",
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
			},
			{
				#  Explicit casts - arithmetic operators and SIZE for int, double and size and concat operators for chararrays
				'num' => 8,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name, age, gpa);
b = foreach a generate (int)age % 25, (int)age + 25, (int)age - 25, (int)age/2, (int)age * 2, SIZE((int)age), (double)gpa + 10.1, (double)gpa - 1.1 , (double)gpa / 1.2, (double)gpa * 2.5, SIZE((double)gpa), SIZE((chararray)name), CONCAT((chararray)name, 'test');
store b into ':OUTPATH:';\,
				'sql' => "select age % 25, age + 25, age - 25, age/2, age * 2, case when age is null then null else 1 end, gpa + 10.1, gpa - 1.1 , gpa / 1.2, gpa * 2.5, case when gpa is null then null else 1 end, char_length(name), name || 'test' from studentnulltab10k;",
			},
			{
				#  Explicit casts - arithmetic operators and SIZE for long, float
				'num' => 9,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name, age, gpa);
b = foreach a generate (long)age, (long)age % 2L, (long)age + 2500000000L, (long)age - 2500000000L, (long)age/2L, (long)age * 250000000L, SIZE((long)age), (float)gpa + 10.1f, (float)gpa - 1.1f , (float)gpa / 1.2f, (float)gpa * 2.6f, SIZE((float)gpa);
store b into ':OUTPATH:';\,
				'sql' => "select age, age % 2, age + 2500000000, age - 2500000000, age/2, cast((age * (cast(250000000 as bigint))) as bigint), case when age is null then null else 1 end, gpa + 10.1, gpa - 1.1 , gpa / 1.2, gpa * 2.6, case when gpa is null then null else 1  end from studentnulltab10k;",
			},
            {
                # Filter is null for chararray and double and is not null for int
                'num' => 10,
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = filter a by name is null and age is not null and gpa is null;
c = group b ALL;
d = foreach c generate COUNT(b);
store d into ':OUTPATH:';\,
                'sql' => "select count(*) from studentnulltab10k where name is null and age is not null and gpa is null;",
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
            },
            {
                # Filter is not null for chararray and double and is null for int
                'num' => 11,
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = filter a by name is not null and age is null and gpa is not null;
c = group b ALL;
d = foreach c generate COUNT(b);
store d into ':OUTPATH:';\,
                'sql' => "select count(*) from studentnulltab10k where name is not null and age is null and gpa is not null;",
            },
            {
                # Filter is null for bytearray and float and is not null for long
                'num' => 12,
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name, age:long, gpa:float);
b = filter a by name is null and age is not null and gpa is null;
c = group b ALL;
d = foreach c generate COUNT(b);
store d into ':OUTPATH:';\,
                'sql' => "select count(*) from studentnulltab10k where name is null and age is not null and gpa is null;",
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
            },
            {
                # Filter is not null for bytearray and float and is null for long
                'num' => 13,
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name, age:long, gpa:float);
b = filter a by name is not null and age is null and gpa is not null;
c = group b ALL;
d = foreach c generate COUNT(b);
store d into ':OUTPATH:';\,
                'sql' => "select count(*) from studentnulltab10k where name is not null and age is null and gpa is not null;",
            },
            {
				# test that sorting is based on the type for chararray, int and double
				'num' => 14,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = order a by name, age, gpa;
store b into ':OUTPATH:';\,
				'sql' => "select * from studentnulltab10k order by name, age, gpa;",
                'sortArgs' => ['-t', '	', '+0', '-1', '+1n', '-2'],
			},
			{
				# test that sorting descending is based on the type for chararray, int and double
				'num' => 15,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = order a by name desc, age desc, gpa desc;
store b into ':OUTPATH:';\,
				'sql' => "select * from studentnulltab10k order by name desc, age desc, gpa desc;",
                'sortArgs' => ['-t', '	', '+0r', '-1', '+1nr', '-2'],
			},
			{
				# test that sorting is based on the type for bytearray, long and float
				'num' => 16,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name, age:long, gpa:float);
b = order a by name, age, gpa;
store b into ':OUTPATH:';\,
				'sql' => "select * from studentnulltab10k order by name, age, gpa;",
                'sortArgs' => ['-t', '	', '+0', '-1', '+1n', '-2'],
			},
			{
				# test that sorting descending is based on the type for chararray, age and float
				'num' => 17,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name, age:long, gpa:float);
b = order a by name desc, age desc, gpa desc;
store b into ':OUTPATH:';\,
				'sql' => "select * from studentnulltab10k order by name desc, age desc, gpa desc;",
                'sortArgs' => ['-t', '	', '+0r', '-1', '+1nr', '-2'],
			},
			{
				# test precision for doubles is atleast 15 digits
				'num' => 18,
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = foreach a generate 0.123456789123456+0.123456789123456;
store b into ':OUTPATH:';\,
				'sql' => "select 0.123456789123456+0.123456789123456 from studentnulltab10k;",
			},
			{
				#  order by string
				'num' => 20,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = order a by name;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by name;",
                'sortArgs' => ['-t', '	', '+0', '-1'],
			},
			{
				#  order by string desc
				'num' => 21,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = order a by name desc;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by name desc;",
                'sortArgs' => ['-t', '	', '+0r', '-1'],
			},
			{
				#  order by int
				'num' => 22,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = order a by age;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by age;",
                'sortArgs' => ['-t', '	', '+1n', '-2'],
			},
			{
				#  order by int desc
				'num' => 23,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = order a by age desc;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by age desc;",
                'sortArgs' => ['-t', '	', '+1nr', '-2'],
			},
			{
				#  order by long
				'num' => 24,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:long, gpa:double);
b = order a by age;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by age;",
                'sortArgs' => ['-t', '	', '+1n', '-2'],
			},
			{
				#  order by long desc
				'num' => 25,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:long, gpa:double);
b = order a by age desc;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by age desc;",
                'sortArgs' => ['-t', '	', '+1nr', '-2'],
			},
			{
				#  order by float
				'num' => 26,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:float);
b = order a by gpa;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by gpa;",
                'sortArgs' => ['-t', '	', '-k 3n'],
			},
			{
				#  order by float desc
				'num' => 27,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:float);
b = order a by gpa desc;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by gpa desc;",
                'sortArgs' => ['-t', '	', '-k 3nr'],
			},
			{
				#  order by double
				'num' => 28,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = order a by gpa;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by gpa;",
                'sortArgs' => ['-t', '	', '-k 3n'],
			},
			{
				#  order by double desc
				'num' => 29,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = order a by gpa desc;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by gpa desc;",
                'sortArgs' => ['-t', '	', '-k 3nr'],
			},
			{
				#  order by *
				'num' => 30,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = order a by *;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by gpa;",
                'sortArgs' => ['-t', '	', '+0', '-1', '+1n', '-2'],
			},
			{
				#  order by * desc
				'num' => 31,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = order a by * desc;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k order by gpa desc;",
                'sortArgs' => ['-t', '	', '+0r', '-1', '+1nr', '-2'],
			},
			{
			'num' => 32,
			'floatpostprocess' => 1,
            'delimiter' => '	',
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa:double);
b = load ':INPATH:/singlefile/votertab10k' as (name:chararray, age:int, registration:chararray, contributions:double);
c = filter a by age < 20;
d = filter b by age < 20;
e = cogroup c by name, d by name;
f = foreach e generate flatten (c), flatten(d);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a full outer join votertab10k as b using(name)
where a.age < 20 and b.age < 20;",
			},
			{
			'num' => 33,
			'floatpostprocess' => 1,
            'delimiter' => '	',
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa:double);
b = load ':INPATH:/singlefile/votertab10k' as (name:chararray, age:int, registration:chararray, contributions:double);
c = filter a by age < 20;
d = filter b by age < 20;
e = cogroup c by age, d by age;
f = foreach e generate flatten (c), flatten(d);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a full outer join votertab10k as b using(age)
where a.age < 20 and b.age < 20;",
			},
			{
			'num' => 34,
			'floatpostprocess' => 1,
            'delimiter' => '	',
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:long, gpa:double);
b = load ':INPATH:/singlefile/votertab10k' as (name:chararray, age:long, registration:chararray, contributions:double);
c = filter a by age < 20;
d = filter b by age < 20;
e = cogroup c by age, d by age;
f = foreach e generate flatten (c), flatten(d);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a full outer join votertab10k as b using(age)
where a.age < 20 and b.age < 20;",
			},
			{
			'num' => 35,
			'floatpostprocess' => 1,
            'delimiter' => '	',
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:float, gpa:double);
b = load ':INPATH:/singlefile/votertab10k' as (name:chararray, age:float, registration:chararray, contributions:double);
c = filter a by age < 20;
d = filter b by age < 20;
e = cogroup c by age, d by age;
f = foreach e generate flatten (c), flatten(d);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a full outer join votertab10k as b using(age)
where a.age < 20 and b.age < 20;",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
			{
			'num' => 36,
			'floatpostprocess' => 1,
            'delimiter' => '	',
			'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:double, gpa:double);
b = load ':INPATH:/singlefile/votertab10k' as (name:chararray, age:double, registration:chararray, contributions:double);
c = filter a by age < 20;
d = filter b by age < 20;
e = cogroup c by age, d by age;
f = foreach e generate flatten (c), flatten(d);
store f into ':OUTPATH:';\,
			'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a full outer join votertab10k as b using(age)
where a.age < 20 and b.age < 20;",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
 			{
				#  NULL and cast
				'num' => 37,
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = foreach a generate (int)((int)gpa/((int)gpa - 1)) as norm_gpa:int;
c = foreach b generate (norm_gpa is not null? norm_gpa: 0);
store c into ':OUTPATH:';\,
				'sql' => "select case when (cast(gpa as integer) - 1 = 0 or gpa is null) then 0 else  cast ((cast(gpa as integer)/(cast(gpa as integer) - 1)) as integer) end from studentnulltab10k;",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			},
			{
				#  constants
				'num' => 38,
				'floatpostprocess' => 1,
                'delimiter' => '	',
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
b = foreach a generate -(age + 1 + 0.2f + 253645L), -(gpa+1);
store b into ':OUTPATH:';\,
				'sql' => "select -(age + 1 + cast(0.2 as float) + 253645), -(gpa + 1) from studentnulltab10k;"
			},
		]
		},
		{
		'name' => 'Limit',
		'floatpostprocess' => 1,
		'tests' => [
			{
                # IMPORTANT NOTE: results need to be compared against old pig 
                # since we order nulls as < any value
                # while postgreSQL does the opposite
				'num' => 1,
                'delimiter' => '	',
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k';
b = order a by $0, $1;
c = filter b by $0 > 'a'; -- break the sort/limit optimization
d = limit c 100;
store d into ':OUTPATH:';\,
				'sql' => "select * from studentnulltab10k where name > 'a' order by name, age  limit 100;",
            	'sortArgs' => ['-t', '	', '+0', '-1'],
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
			},
			{
				'num' => 2,
                'delimiter' => '	',
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k';
b = order a by $0, $1;
c = limit b 100;
store c into ':OUTPATH:';\,
				'sql' => "select * from studentnulltab10k order by name, age  limit 100;",
            	'sortArgs' => ['-t', '	', '+0', '-1'],
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
			},
			{
				# Make sure that limit higher than number of rows doesn't mess stuff up
				'num' => 3,
                'delimiter' => '	',
				'pig' =>q\a = load ':INPATH:/singlefile/studenttab10k';
b = order a by $0, $1;
c = filter b by $1 < 1000;
d = limit c 100000;
store d into ':OUTPATH:';\,
				'sql' => "select * from studenttab10k order by name, age;",
			},
			{
				'num' => 4,
                'delimiter' => '	',
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k';
b = distinct a;
c = limit b 100;
store c into ':OUTPATH:';\,
				'sql' => "select distinct * from studentnulltab10k limit 100;",
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
			},
			{
				'num' => 5,
                'delimiter' => '	',
				'pig' =>q\a = load ':INPATH:/singlefile/studenttab10k';
b = load ':INPATH:/singlefile/votertab10k';
a1 = foreach a generate $0, $1;
b1 = foreach b generate $0, $1;
c = union a1, b1;
d = limit c 100;
store d into ':OUTPATH:';\,
				'sql' => "select name, age from studenttab10k
union all
select name, age from votertab10k
limit 100;;",
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
			},
			{
				'num' => 6,
                'delimiter' => '	',
				'pig' =>q\A = load ':INPATH:/singlefile/studenttab10k' as (name: chararray, age: int, gpa: float);
B = limit A 40;
C = filter B by age == 40;
D = group C by name;
E = foreach D generate group, COUNT(C);
store E into ':OUTPATH:';\,
				'sql' => "select name, count(*) from (select * from studenttab10k limit 40) where age = 40 group by name;",
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
			},
			{
				'num' => 7,
                'delimiter' => '	',
				'pig' =>q\A = load ':INPATH:/singlefile/studenttab10k' as (name: chararray, age: int, gpa: float);
B = group A by name;
C = foreach B {
	C1 = limit A 10;
	generate group, COUNT(C1);
}
store C into ':OUTPATH:';\,
				'sql' => "select name, case when count(*) > 10 then 10 else count(*) end from studenttab10k group by name;",
			},
			{
				'num' => 8,
                'delimiter' => '	',
				'pig' =>q\A = load ':INPATH:/singlefile/studenttab10k' as (name: chararray, age: int, gpa: float);
B = group A by name;
C = foreach B {
	C1 = filter A by age < 40;
	C2 = limit C1 10;
	generate group, COUNT(C2);
}
D = filter C by $1 > 0;
store D into ':OUTPATH:';\,
				'sql' => "select name, case when count(*) > 10 then 10 else count(*) end from studenttab10k where age < 40 group by name;",
			}
		]
		},
		{
		'name' => 'Split',
		'floatpostprocess' => 1,
        'delimiter' => '	',
		'tests' => [
			{
				'num' => 1,
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k';
split a into a1 if $0 > 'm', a2 if $0 <= 'm'; 
store a1 into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k where name > 'm';",
			},
			{
				'num' => 2,
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k';
split a into a1 if $0 > 'm', a2 if $0 <= 'm'; 
store a2 into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k where name <= 'm';",
			},
			{
				'num' => 3,
				'pig' =>q\a = load ':INPATH:/singlefile/studenttab10k';
split a into a1 if $0 > 'm', a2 if $0 <= 'm'; 
b = cogroup a1 by $1, a2 by $1;
c = foreach b generate flatten(a1), flatten(a2);
store c into ':OUTPATH:';\,
				'sql' => "select A.name, A.age, A.gpa, B.name, B.age, B.gpa
from (select * from studenttab10k where name > 'm') as A
	join (select * from studenttab10k where name <= 'm') as B using (age);",
			},
			{
				'num' => 4,
				'pig' =>q\a = load ':INPATH:/singlefile/studenttab10k';
split a into a1 if $0 > 'm', a2 if $0 <= 'm'; 
b = cogroup a1 by $1, a2 by $1;
c = foreach b generate flatten($1), flatten($2);
store c into ':OUTPATH:';\,
				'sql' => "select A.name, A.age, A.gpa, B.name, B.age, B.gpa
from (select * from studenttab10k where name > 'm') as A
	join (select * from studenttab10k where name <= 'm') as B using (age);",
			},
			{
				'num' => 5,
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name, age, gpa);
split a into a1 if name > 'm', a2 if name <= 'm'; 
b = distinct a1;
store b into ':OUTPATH:';\,
				'sql' => "select distinct name, age, gpa from studentnulltab10k where name > 'm';",
			},
			{
				'num' => 6,
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name, age, gpa);
split a into a1 if age > 50, a2 if age <= 25; 
b = order a2 by name;
store b into ':OUTPATH:';\,
				'sql' => "select name, age, gpa from studentnulltab10k where age <= 25 order by name;",
				'sortArgs' => ['-t', '	', '+0', '-1'],
			},
			{
				'num' => 7,
				'pig' =>q\a = load ':INPATH:/singlefile/studentnulltab10k' as (name:chararray, age:int, gpa:double);
split a into a1 if name > 'm', a2 if age < 50; 
b = distinct a1;
store b into ':OUTPATH:';\,
				'sql' => "select distinct name, age, gpa from studentnulltab10k where name > 'm';",
			},
			{
				'num' => 8,
				'pig' =>q\a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:double);
split a into a1 if age > 50, a2 if name < 'm'; 
b2 = foreach a2 generate name, 1;
b1 = foreach a1 generate name, 2;
c = cogroup b2 by name, b1 by name;
d = foreach c generate flatten(group), COUNT($1), COUNT($2);
store d into ':OUTPATH:';\,
				'sql' => "select A.name, count(*)
from (select distinct * from studenttab10k where age > 50) as A
	join (select * from studenttab10k where name < 'm') as B using (name)
group by A.name;",
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
			},
			{
				'num' => 9,
				'pig' =>q\a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:double);
split a into a1 if age > 50, a2 if name < 'm'; 
b2 = distinct a2;
b1 = order a1 by name;
c = cogroup b2 by name, b1 by name;
d = foreach c generate flatten(group), COUNT($1), COUNT($2);
store d into ':OUTPATH:';\,
				'sql' => "select A.name, B.name, count(*)
from (select distinct * from studenttab10k where age > 50) as A
	join (select * from studenttab10k where name < 'm') as B using (name)
group by name;",
				'verify_with_pig' => 1,
				'verify_pig_version' => 'old',
			}
		]
		},
		{
		'name' => 'ImplicitSplit',
		'floatpostprocess' => 1,
        'delimiter' => '	',
		'tests' => [
			{
				'num' => 1,
				'pig' =>q\a = load ':INPATH:/singlefile/studenttab10k';
b = filter a by $1 > 50;
c = filter a by $2 > 3.0;
d = cogroup b by $0, c by $0;
e = foreach d generate flatten(b), flatten(c);
store e into ':OUTPATH:';\,
				'sql' => "select A.name, A.age, A.gpa, B.name, B.age, B.gpa
from (select * from studenttab10k where age > 50) as A
	join (select * from studenttab10k where gpa > 3.0) as B using (name);",
			},
			{
				'num' => 2,
				'pig' =>q\a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:double);
b = filter a by age > 50;
c = filter a by gpa > 3.0;
d = cogroup b by name, c by name;
e = foreach d generate flatten(b), flatten(c);
f = filter e by b::age < 75;
store f into ':OUTPATH:';\,
				'sql' => "select A.name, A.age, A.gpa, B.name, B.age, B.gpa
from (select * from studenttab10k where age > 50) as A
	join (select * from studenttab10k where gpa > 3.0) as B using (name)
where A.age < 75;",
			}
		]
		},
		{
		'name' => 'describe',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
                        #JIRA[PIG-373]
			{
			'num' => 1,
			'pig' => q\ 
A = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa: double);
describe A;
store A into ':OUTPATH:';\,

            'sql' => "select name, age, gpa from studenttab10k;",
			},
		],
		},
		{
		'name' => 'MissingColumns',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
			{
			'num' => 1,
			'pig' => q\ 
A = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age: int, gpa: double, extra: chararray);
B = filter A by age > 50 or extra > 'm';
D = order B by age, extra;
store D into ':OUTPATH:';\,

            'sql' => "select name, age, gpa from studenttab10k where age > 50;",
			'sortArgs' => ['-t', '	', '+1n', '-2'],
			},
			{
			'num' => 2,
			'pig' => q\ 
A = load ':INPATH:/singlefile/studenttab10k' using PigStorage();
B = foreach A generate $0, $1 + 1, $3 + 1;
C = group B by ($0, $2);
D = foreach C generate flatten(group), COUNT($1);
store D into ':OUTPATH:';\,

            'sql' => "select name, '', count(*) from studenttab10k group by name;",
			},
			{
			'num' => 3,
			'pig' => q\ 
A = load ':INPATH:/singlefile/studenttab10k' as (name: chararray, age: int, gpa: double);
B = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa, extra1, extra2);
C = join A by (name, age), B by (name, extra1);
store C into ':OUTPATH:';\,

			# The following SQL should produce empty results, which will match what our pig query should produce.
            'sql' => "select * from studenttab10k as S, votertab10k as V where S.name = V.registration;",
			}
		],
		},
		{
		'name' => 'Aliases',
        # check access of a field using multiple valid aliases
		'tests' => [
			{
            # check that a free standing alias reference works
            # when it is unambiguous
            # check that a fully qualified alias reference works
            # check that a partially qualified unambiguous alias reference works
			'num' => 1,
			'pig' => q\ 
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa: double);
b = group a by name;
c = foreach b generate flatten(a);
d = filter c by name != 'fred';
e = group d by name;
f = foreach e generate flatten(d);
g = foreach f generate name, d::a::name as dname, a::name as aname;
store g into ':OUTPATH:';\,

            'sql' => "select name, name, name from studenttab10k;",
			},
			{
            # check that the "group" alias is available
            # after a flatten(group)
			'num' => 2,
			'pig' => q\ 
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa: double);
b = group a by name;
c = foreach b generate flatten(group), COUNT(a) as cnt;
d = foreach c generate group;
store d into ':OUTPATH:';\,

            'sql' => "select distinct name from studenttab10k;",
			},
		],
		},

		{
		'name' => 'Lineage',
        #test if the right cast function is picked
		'tests' => [
			{
			'num' => 1,
			'pig' => q\ 
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/textdoc' using TextLoader() as (sentence);
c = cogroup a ALL, b ALL;
d = foreach c generate flatten(a), flatten(b);
e = foreach d generate name, flatten(TOKENIZE((chararray)sentence)) as sentence;
f = foreach e generate CONCAT((chararray)name, sentence);
store f into ':OUTPATH:';\,

			'sql' => "select a.name || b.name from studenttab10k as a cross join textdoc as b ;",
			},
			{
			'num' => 2,
			'pig' => q\ 
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age:int, gpa: double);
b = load ':INPATH:/singlefile/textdoc' using TextLoader() as (sentence);
c = cross a, b;
d = foreach c generate name, flatten(TOKENIZE((chararray)sentence)) as sentence;
e = foreach d generate CONCAT((chararray)name, sentence);
store e into ':OUTPATH:';\,

			'sql' => "select a.name || b.name from studenttab10k as a cross join textdoc as b ;",
			},
                        {
                        'num' => 3,
                        'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa: double);
b = foreach a generate age as student_age;
c = filter b by student_age > 50;
d = foreach c generate student_age + 10;
store d into ':OUTPATH:';\,

                        'sql' => "select age + 10 from studenttab10k where age > 50 ;",
                        },
			{
			'num' => 4,
			'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = filter a by name lt 'b';
c = foreach b generate org.apache.pig.test.udf.evalfunc.CreateMap((chararray)name, (int)age);
d = foreach c generate $0#'alice young';
split d into e if $0 is not null, f if $0 is null;
store e into ':OUTPATH:';\,
			'sql' => "select age from studenttab10k where name = 'alice young';",
			}
		],
		},
        {
		'name' => 'Casts',
		'tests' => [
			{
            # check that a cast of a value of type
            # same as the result type of the cast works
            # when the value is treated as a bytearray
			'num' => 1,
			'floatpostprocess' => 1,
			'delimiter' => '	',
			'pig' => q\ 
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa: double);
b = foreach a generate name, age, gpa;
store b into ':OUTPATH:.intermediate' using BinStorage();
c = load ':OUTPATH:.intermediate' using BinStorage();
-- after this load, the fields are treated as bytearrays though
-- they are actually "typed", test that the implicit casts 
-- introduced by the operations in the foreach below will work fine
d = foreach c generate CONCAT((chararray)$0, 'test'), $1 + 1, $2 + 0.2;
store d into ':OUTPATH:';\,

            'sql' => "select name || 'test' , age + 1, gpa + 0.2 from studenttab10k;",
			},
			{
            # check that a cast of a value of type
            # same as the result type of the cast works
            # when the value is treated as a bytearray
			'num' => 2,
			'floatpostprocess' => 1,
			'delimiter' => '	',
			'pig' => q\ 
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:long, gpa: float);
b = foreach a generate name, age, gpa;
store b into ':OUTPATH:.intermediate' using BinStorage();
c = load ':OUTPATH:.intermediate' using BinStorage();
-- after this load, the fields are treated as bytearrays though
-- they are actually "typed", test that the implicit casts 
-- introduced by the operations in the foreach below will work fine
d = foreach c generate CONCAT((chararray)$0, 'test'), $1 + 1L, $2 + 0.2f;
store d into ':OUTPATH:';\,

            'sql' => "select name || 'test' , age + 1, gpa + 0.2 from studenttab10k;",
			},
			{
             #check that a cast of a value of type
             #same as the result type of the cast works
             #when the value is treated as a bytearray
			'num' => 3,
			'floatpostprocess' => 1,
			'delimiter' => '	',
			'pig' => q\ 
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:long, gpa: float);
b = group a by  name;
c = foreach b generate a, (1,2,3), ['key1'#'value1','key2'#'value2'];
-- store the bag, tuple and map
store c into ':OUTPATH:.intermediate' using BinStorage();
d = load ':OUTPATH:.intermediate' using BinStorage() as (b:bag{t:tuple(x,y,z)}, t2:tuple(a,b,c), m:map[]);
-- after this load, the fields are treated as bytearrays though
-- they are actually "typed", test that the implicit casts 
-- introduced by the operations in the foreach below will work fine
e = foreach d generate COUNT(b), t2.a, t2.b, t2.c, m#'key1', m#'key2';
store e into ':OUTPATH:';\,

            'sql' => "select COUNT(*), 1 , 2, 3, 'value1', 'value2' from studenttab10k group by name;",
			},
			{
            # check that a cast of a value of type
            # same as the result type of the cast works
            # when the value is treated as a bytearray
			'num' => 4,
			'floatpostprocess' => 1,
			'delimiter' => '	',
			'pig' => q\ 
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa: double);
b = foreach a generate name, age, gpa;
store b into ':OUTPATH:.intermediate' using PigStorage();
c = load ':OUTPATH:.intermediate' using PigStorage();
-- after this load, the fields are treated as bytearrays though
-- they are actually "typed", test that the implicit casts 
-- introduced by the operations in the foreach below will work fine
d = foreach c generate CONCAT((chararray)$0, 'test'), $1 + 1, $2 + 0.2;
store d into ':OUTPATH:';\,

            'sql' => "select name || 'test' , age + 1, gpa + 0.2 from studenttab10k;",
			},
			{
            # check that a cast of a value of type
            # same as the result type of the cast works
            # when the value is treated as a bytearray
			'num' => 5,
			'floatpostprocess' => 1,
			'delimiter' => '	',
			'pig' => q\ 
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:long, gpa: float);
b = foreach a generate name, age, gpa;
store b into ':OUTPATH:.intermediate' using PigStorage();
c = load ':OUTPATH:.intermediate' using PigStorage();
-- after this load, the fields are treated as bytearrays though
-- they are actually "typed", test that the implicit casts 
-- introduced by the operations in the foreach below will work fine
d = foreach c generate CONCAT((chararray)$0, 'test'), $1 + 1L, $2 + 0.2f;
store d into ':OUTPATH:';\,

            'sql' => "select name || 'test' , age + 1, gpa + 0.2 from studenttab10k;",
			},
			{
             #check that a cast of a value of type
             #same as the result type of the cast works
             #when the value is treated as a bytearray
			'num' => 6,
			'floatpostprocess' => 1,
			'delimiter' => '	',
			'pig' => q\ 
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:long, gpa: float);
b = group a by  name;
c = foreach b generate a, (1,2,3), ['key1'#'value1','key2'#'value2'];
-- store the bag, tuple and map
store c into ':OUTPATH:.intermediate' using PigStorage();
d = load ':OUTPATH:.intermediate' using PigStorage() as (b:bag{t:tuple(x,y,z)}, t2:tuple(a,b,c), m:map[]);
-- after this load, the fields are treated as bytearrays though
-- they are actually "typed", test that the implicit casts 
-- introduced by the operations in the foreach below will work fine
e = foreach d generate COUNT(b), t2.a, t2.b, t2.c, m#'key1', m#'key2';
store e into ':OUTPATH:';\,

            'sql' => "select COUNT(*), 1 , 2, 3, 'value1', 'value2' from studenttab10k group by name;",
			},

		],
        },
        {
		'name' => 'ClassResolution',
		'tests' => [
			{
            # check that Loader specified without a package
            # name works if that package name is specified
            # in udf.import.list
			'num' => 1,
			'floatpostprocess' => 1,
			'delimiter' => '	',
	'java_params' => ['-Dudf.import.list=org.apache.pig.test.udf.storefunc'],
			'pig' => q\ 
register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa: double);
b = foreach a generate CONCAT('(', name), CONCAT((chararray)age, ' )');
store b into ':OUTPATH:.intermediate' using PigStorage(',');
c = load ':OUTPATH:.intermediate' using DumpLoader();
store c into ':OUTPATH:';\,

            'sql' => "select name , age from studenttab10k;",
			},
		],
        },

	{
		'name' => 'MergeJoin',
		'floatpostprocess' => 1,
		'delimiter' => '	',
		'tests' => [
				# Simplest merge-join.
				{
				'num' => 1,
				'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
					b = load ':INPATH:/singlefile/votertab10k'; 
					c = order a by $0;
					d = order b by $0;
					store c into ':OUTPATH:.intermediate1';
					store d into ':OUTPATH:.intermediate2';
					exec;
					e = load ':OUTPATH:.intermediate1';
					f = load ':OUTPATH:.intermediate2';
					g = join e by $0, f by $0 using 'merge';
					store g into ':OUTPATH:';\,
				'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions from studenttab10k as a join votertab10k as b using(name)",
				},
				# Merge-join with left-side filter
				{
				'num' => 2,
				'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
					b = load ':INPATH:/singlefile/votertab10k'; 
					c = order a by $0;
					d = order b by $0;
					store c into ':OUTPATH:.intermediate1';
					store d into ':OUTPATH:.intermediate2';
					exec;					
					e = load ':OUTPATH:.intermediate1';
					h = filter e by $1 > 30;					
					f = load ':OUTPATH:.intermediate2';
					g = join h by $0, f by $0 using 'merge';
					store g into ':OUTPATH:';\,
				'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions from studenttab10k as a join votertab10k as b using(name) where a.age > 30",
				},
				# Merge-join with right-side filter
				{
				'num' => 3,
				'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
					b = load ':INPATH:/singlefile/votertab10k'; 
					c = order a by $0;
					d = order b by $0;
					store c into ':OUTPATH:.intermediate1';
					store d into ':OUTPATH:.intermediate2';
					exec;					
					e = load ':OUTPATH:.intermediate1';
					f = load ':OUTPATH:.intermediate2';
					i = filter f by $2 != 'democrat';
					g = join e by $0, i by $0 using 'merge';
					store g into ':OUTPATH:';\,
				'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions from studenttab10k as a join votertab10k as b using(name) where  b.registration != 'democrat'",
				},
				# Merge-join with schemas
				{
				'num' => 4,
				'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
					b = load ':INPATH:/singlefile/votertab10k'; 
					c = order a by $0;
					d = order b by $0;
					store c into ':OUTPATH:.intermediate1';
					store d into ':OUTPATH:.intermediate2';
					exec;					
					e = load ':OUTPATH:.intermediate1'  as (name:chararray, age:int, gpa:float);
					f = load ':OUTPATH:.intermediate2'  as (name:chararray, age:int, reg:chararray, contrib:float);
					g = join e by $0, f by $0 using 'merge';
					store g into ':OUTPATH:';\,
				'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions from studenttab10k as a join votertab10k as b using(name)",
				},
				# Merge-join with key as expression
				{
				'num' => 5,
				'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
					b = load ':INPATH:/singlefile/votertab10k'; 
					c = order a by $0,$1;
					d = order b by $0,$1;
					store c into ':OUTPATH:.intermediate1';
					store d into ':OUTPATH:.intermediate2';
					exec;
					e = load ':OUTPATH:.intermediate1';
					f = load ':OUTPATH:.intermediate2';
					g = join e by ($0,$1), f by ($0,$1) using 'merge';
					store g into ':OUTPATH:';\,
				'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions from studenttab10k as a join votertab10k as b using(name,age)",
				},
				# Merge-join with key as expression This expression guarantees ordering 
				{
				'num' => 6,
				'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
					b = load ':INPATH:/singlefile/votertab10k'; 
					c = order a by $1;
					d = order b by $1;
					store c into ':OUTPATH:.intermediate1';
					store d into ':OUTPATH:.intermediate2';
					exec;
					e = load ':OUTPATH:.intermediate1';
					f = load ':OUTPATH:.intermediate2';
					g = join e by ($1+10), f by ($1+10) using 'merge';
					store g into ':OUTPATH:';\,
				'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions from studenttab10k as a join votertab10k as b using(age)",
				},
				# Merge-join with nulls in keys and data.
				{
				'num' => 7,
				'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k';
					b = load ':INPATH:/singlefile/voternulltab10k'; 
					c = order a by $0;
					d = order b by $0;
					store c into ':OUTPATH:.intermediate1';
					store d into ':OUTPATH:.intermediate2';
					exec;
					e = load ':OUTPATH:.intermediate1';
					f = load ':OUTPATH:.intermediate2';
					g = join e by $0, f by $0 using 'merge';
					store g into ':OUTPATH:';\,
				'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions from studentnulltab10k as a join voternulltab10k as b using(name)",
				},
				# Merge-join with one file across multiple blocks
        	                {
                                'num' => 8,
			                    'exectype' => 'mapred', # since this join will run out of memory in local mode
                                'pig' => q\a = load ':INPATH:/singlefile/votertab10k';
                                        b = load ':INPATH:/singlefile/studenttab20m';
                                        h = filter b by $2 < 1.5;
                                        c = order a by $0;
                                        d = order h by $0 parallel 1;
                                        store c into ':OUTPATH:.intermediate1';
                                        store d into ':OUTPATH:.intermediate2';
                                        exec;
                                        e = load ':OUTPATH:.intermediate1' as (name:chararray, age:int, reg:chararray, contrib:float);
                                        f = load ':OUTPATH:.intermediate2'as (name:chararray, age:int, gpa:float);
                                        g = join e by $0, f by $0 using 'merge';
                                        i = filter g by $2 == 'democrat' and $1 > 76;
                                        store i into ':OUTPATH:';\,
                                'sql' => "select b.name, b.age, b.registration, b.contributions, a.name, a.age, a.gpa  from studenttab20m as a join votertab10k as b using(name) where a.gpa < 1.5 and b.registration = 'democrat' and b.age > 76",
                                }, 
				# Merge-join with join on numeric key
				{
				'num' => 9,
				'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:float);
					b = load ':INPATH:/singlefile/votertab10k'as (name:chararray, age:int, reg:chararray, contrib:float);
					c = order a by age;
					d = order b by age;
					store c into ':OUTPATH:.intermediate1';
					store d into ':OUTPATH:.intermediate2';
					exec;					
					e = load ':OUTPATH:.intermediate1'  as (name:chararray, age:int, gpa:float);
					f = load ':OUTPATH:.intermediate2'  as (name:chararray, age:int, reg:chararray, contrib:float);
					g = join e by age, f by age using 'merge';
					store g into ':OUTPATH:';\,
				'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions from studenttab10k as a join votertab10k as b using(age)",
				},

			]
		},
                {
                'name' => 'SkewedJoin',
		'floatpostprocess' => 1,
		'delimiter' => '	',
                'tests' => [
                        {
                        'num' => 1,
                        'java_params' => ['-Dpig.skewedjoin.reduce.maxtuple=100'],
                        'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
e = join a by name, b by name using 'skewed' parallel 8;
store e into ':OUTPATH:';\,
                        'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a join votertab10k as b using(name);",
                        },

                # basic join with no skewed keys
                       {
                        'num' => 2,
                        'java_params' => ['-Dpig.skewedjoin.reduce.maxtuple=10000'],
                        'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age,
gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
e = join a by name, b by name using 'skewed';
store e into ':OUTPATH:';\,
                        'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a join votertab10k as b using(name) ;",
                        },

                # join after filtering
                        {
                        'num' => 3,
                        'java_params' => ['-Dpig.skewedjoin.reduce.maxtuple=3'],
                        'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age,
gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 20;
d = filter b by age < 20;
e = join c by $0, d by $0 using 'skewed' parallel 8;
store e into ':OUTPATH:';\,
                        'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a join votertab10k as b using(name)
where a.age < 20 and b.age < 20;",
                        },

                # join by two columns
                        {
                        'num' => 4,
                        'java_params' => ['-Dpig.skewedjoin.reduce.maxtuple=3'],
                        'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 20;
d = filter b by age < 20;
e = join c by (name, age), d by (name, age) using 'skewed' parallel 8;
store e into ':OUTPATH:';\,
                        'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a join votertab10k as b using(name, age)
where a.age < 20 and b.age < 20;",
                        },

                # join with add
                       {
                        'num' => 5,
                        'java_params' => ['-Dpig.skewedjoin.reduce.maxtuple=50'],
                        'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray,age:int, gpa:double);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 20;
d = filter b by age < 20;
e = join c by age+10, d by age + 20 using 'skewed' parallel 10;
store e into ':OUTPATH:';\,
                        'sql' => "select studenttab10k.*, votertab10k.*
from studenttab10k , votertab10k where studenttab10k.age<20 AND votertab10k.age<20 AND studenttab10k.age = votertab10k.age+10;",
                        },

                # join with split
                       {
                        'num' => 6,
                        'java_params' => ['-Dpig.skewedjoin.reduce.maxtuple=100'],
                        'pig' => q\a = load ':INPATH:/singlefile/studenttab10k';
b = filter a by $1 > 25;
c = join a by $0, b by $0 using 'skewed' parallel 7;
store c into ':OUTPATH:';\,
                        'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.gpa
from studenttab10k as a join studenttab10k as b using(name)
where b.age > 25;",
                        },

		# join with UDF
                       {
                        'num' => 7,
                        'java_params' => ['-Dpig.skewedjoin.reduce.maxtuple=20'],
                        'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 20;
d = filter b by age < 20;
e = join c by SIZE(name), d by SIZE(name) using 'skewed' parallel 7;
store e into ':OUTPATH:';\,
                        'sql' => "select studenttab10k.*, votertab10k.*
from studenttab10k, votertab10k where studenttab10k.age<20 AND votertab10k.age<20 AND LENGTH(studenttab10k.name) = LENGTH(votertab10k.name);",
                        },
		# left outer join
                        {
                        'num' => 8,
                        'java_params' => ['-Dpig.skewedjoin.reduce.maxtuple=100'],
                        'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
e = join a by name left outer, b by name using 'skewed' parallel 8;
store e into ':OUTPATH:';\,
                        'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a left outer join votertab10k as b using(name);",
                        },
		# right outer join
                        {
                        'num' => 9,
                        'java_params' => ['-Dpig.skewedjoin.reduce.maxtuple=100'],
                        'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
e = join a by name right outer, b by name using 'skewed' parallel 8;
store e into ':OUTPATH:';\,
                        'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a right outer join votertab10k as b using(name);",
                        },
		# full outer join
                        {
                        'num' => 10,
                        'java_params' => ['-Dpig.skewedjoin.reduce.maxtuple=100'],
                        'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
e = join a by name full outer, b by name using 'skewed' parallel 8;
store e into ':OUTPATH:';\,
                        'sql' => "select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a full outer join votertab10k as b using(name);",
                        },
                ]

            },

            {
            'name' => 'CollectedGroup',
            'floatpostprocess' => 1,
            'delimiter' => '	',
            'tests' => [
                    # Simplest collected group.
                    {
                    'num' => 1,
                    'pig' => q\a = load ':INPATH:/singlefile/studenttab10k'; 
                            b = order a by $0;
                            store b into ':OUTPATH:.intermediate';
                            exec;
                       	    register :FUNCPATH:/testudf.jar;	     
			    c = load ':OUTPATH:.intermediate' using org.apache.pig.test.udf.storefunc.SimpleCollectableLoader();
                            d = group c by $0 using 'collected';
                            e = foreach d generate group, COUNT(c);
                            store e into ':OUTPATH:';\,
                    'sql' => "select name, count(*) from studenttab10k group by name",
                    },
                    # Collected group with filter
                    {
                    'num' => 2,
                    'pig' => q\a = load ':INPATH:/singlefile/studenttab10k'; 
                            b = order a by $0;
                            store b into ':OUTPATH:.intermediate';
                            exec;
                       	    register :FUNCPATH:/testudf.jar;	     
			    c = load ':OUTPATH:.intermediate' using org.apache.pig.test.udf.storefunc.SimpleCollectableLoader();
                            d = filter c by $1 > 30;
                            e = group d by $0 using 'collected';
                            f = foreach e generate group, COUNT(d);
                            store f into ':OUTPATH:';\,
                    'sql' => "select name, count(*) from studenttab10k where age > 30 group by name",
                    },
                    # Collected group with schemas
                    {
                    'num' => 3,
                    'pig' => q\a = load ':INPATH:/singlefile/studenttab10k'; 
                            b = order a by $0;
                            store b into ':OUTPATH:.intermediate';
                            exec;
                       	    register :FUNCPATH:/testudf.jar;	     
			    c = load ':OUTPATH:.intermediate' using org.apache.pig.test.udf.storefunc.SimpleCollectableLoader() as (name:chararray, age:int, gpa:float);
                            d = group c by $0 using 'collected';
                            e = foreach d generate group, MAX(c.age);
                            store e into ':OUTPATH:';\,
                    'sql' => "select name, max(age) from studenttab10k group by name",
                    },
                    # Collected group with multiple columns
                    {
                    'num' => 4,
                    'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
                            b = order a by name, age;
                            store b into ':OUTPATH:.intermediate';
                            exec;
                       	    register :FUNCPATH:/testudf.jar;	     
			    c = load ':OUTPATH:.intermediate' using org.apache.pig.test.udf.storefunc.SimpleCollectableLoader() as (name:chararray, age:int, gpa:float);
                            d = group c by (name, age) using 'collected';
                            e = foreach d generate group.name, group.age, MIN(c.gpa);
                            store e into ':OUTPATH:';\,
                    'sql' => "select name, age, min(gpa) from studenttab10k group by name, age",
                    },
                    # Collected group with nulls in keys and data.
                    {
                    'num' => 5,
                    'pig' => q\a = load ':INPATH:/singlefile/studentnulltab10k'; 
                            b = order a by $0;
                            store b into ':OUTPATH:.intermediate';
                            exec;
                       	    register :FUNCPATH:/testudf.jar;	     
			    c = load ':OUTPATH:.intermediate' using org.apache.pig.test.udf.storefunc.SimpleCollectableLoader() as (name:chararray, age:int, gpa:float);
                            d = group c by $0 using 'collected';
                            e = foreach d generate group, SUM(c.$1);
                            store e into ':OUTPATH:';\,
                    'sql' => "select name, sum(age) from studentnulltab10k group by name",
                    },
                    # Collected group with numeric key
                    {
                    'num' => 6,
                    'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:float);
                            b = order a by age;
                            store b into ':OUTPATH:.intermediate';
                            exec;
                       	    register :FUNCPATH:/testudf.jar;	     
			    c = load ':OUTPATH:.intermediate' using org.apache.pig.test.udf.storefunc.SimpleCollectableLoader() as (name:chararray, age:int, gpa:float);
                            d = group c by age using 'collected';
                            e = foreach d generate group, AVG(c.gpa), COUNT(c.name);
                            store e into ':OUTPATH:';\,
                    'sql' => "select age, avg(gpa), count(name) from studenttab10k group by age",
                    },
                ]
            },
            {
            'name' => 'SecondarySort',
            'floatpostprocess' => 1,
            'delimiter' => '	',
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
            'tests' => [
                    {
                    # simple order by
                    'num' => 1,
                    'java_params' => ['-Dpig.accumulative.batchsize=5'],
                    'pig' => q\register :FUNCPATH:/testudf.jar;
                            a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
                            b = group a by age parallel 10;
                            c = foreach b {
                                d = order a by name;
                                generate group, org.apache.pig.test.udf.evalfunc.AllFirstLetter(d);
                            };
                            store c into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1<0",
                    },
                    {
                    # order by desc
                    'num' => 2,
                    'java_params' => ['-Dpig.accumulative.batchsize=5'],
                    'pig' => q\register :FUNCPATH:/testudf.jar;
                            a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
                            b = group a by age parallel 10;
                            c = foreach b {
                                d = order a by name desc;
                                generate group, org.apache.pig.test.udf.evalfunc.AllFirstLetter(d);
                            };
                            store c into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1<0",
                    },
                    {
                    # order by float type
                    'num' => 3,
                    'java_params' => ['-Dpig.accumulative.batchsize=5'],
                    'pig' => q\register :FUNCPATH:/testudf.jar;
                            a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:float);
                            b = group a by age parallel 10;
                            c = foreach b {
                                d = order a by gpa;
                                generate group, org.apache.pig.test.udf.evalfunc.AllFirstLetter(d.gpa);
                            };
                            store c into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1<0",
                    },
                    # order by string type
                    {
                    'num' => 4,
                    'java_params' => ['-Dpig.accumulative.batchsize=5'],
                    'pig' => q\register :FUNCPATH:/testudf.jar;
                            a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:float);
                            b = group a by age parallel 10;
                            c = foreach b {
                                d = order a by name;
                                generate group, org.apache.pig.test.udf.evalfunc.AllFirstLetter(d.name);
                            };
                            store c into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1<0",
                    },
                    # simple distinct
                    {
                    'num' => 5,
                    'java_params' => ['-Dpig.exec.nocombiner=true', '-Dpig.accumulative.batchsize=5'],
                    'pig' => q\register :FUNCPATH:/testudf.jar;
                            a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:float);
                            b = group a by age parallel 10;
                            c = foreach b {
                                d = a.name;
                                e = distinct d;
                                generate group, org.apache.pig.test.udf.evalfunc.AllFirstLetter(e);
                            };
                            store c into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1<0",
                    },
                    # distinct on tuple
                    {
                    'num' => 6,
                    'java_params' => ['-Dpig.exec.nocombiner=true', '-Dpig.accumulative.batchsize=5'],
                    'pig' => q\register :FUNCPATH:/testudf.jar;
                            a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:float);
                            b = group a by age parallel 10;
                            c = foreach b {
                                d = distinct a;
                                generate group, org.apache.pig.test.udf.evalfunc.AllFirstLetter(d);
                            };
                            store c into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1<0",
                    },
                    # sort by two columns
                    {
                    'num' => 7,
                    'java_params' => ['-Dpig.accumulative.batchsize=5'],
                    'pig' => q\register :FUNCPATH:/testudf.jar;
                            a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:float);
                            b = group a by age parallel 10;
                            c = foreach b {
                                d = order a by gpa, name desc;
                                generate group, org.apache.pig.test.udf.evalfunc.AllFirstLetter(d.gpa), org.apache.pig.test.udf.evalfunc.AllFirstLetter(d.name);
                            };
                            store c into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1<0",
                    },
                    # sort, distinct mix
                    {
                    'num' => 8,
                    'java_params' => ['-Dpig.exec.nocombiner=true', '-Dpig.accumulative.batchsize=5'],
                    'pig' => q\register :FUNCPATH:/testudf.jar;
                            a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:float);
                            b = group a by age parallel 10;
                            c = foreach b {
                                d = order a by name;
                                e = d.gpa;
                                f = distinct e;
                                generate group, org.apache.pig.test.udf.evalfunc.AllFirstLetter(f); 
                            };
                            store c into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1<0",
                    },
                    # sort, distinct mix
                    {
                    'num' => 9,
                    'java_params' => ['-Dpig.exec.nocombiner=true', '-Dpig.accumulative.batchsize=5'],
                    'pig' => q\register :FUNCPATH:/testudf.jar;
                            a = load ':INPATH:/singlefile/studenttab10k' as (name:chararray, age:int, gpa:float);
                            b = group a by age parallel 10;
                            c = foreach b {
                                d = order a by gpa;
                                e = d.gpa;
                                f = distinct e;
                                generate group, org.apache.pig.test.udf.evalfunc.AllFirstLetter(f); 
                            };
                            store c into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1<0",
                    },
                ]
            },
            {
            'name' => 'Accumulator',
            'floatpostprocess' => 1,
            'delimiter' => '	',
            'tests' => [
                    {
                    'num' => 1,
                    'java_params' => ['-Dpig.exec.nocombiner=true', '-Dpig.accumulative.batchsize=5'],
                    'pig' => q\a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age:int, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
e = cogroup a by name, b by name parallel 8;
f = foreach e generate group,  SUM(a.age) as s;
g = filter f by s>0;
store g into ':OUTPATH:';\,
                    'sql' => "select name,  sum(age)  from studenttab10k group by name;",
                    },
                    {
                    'num' => 2,
                    'java_params' => ['-Dpig.exec.nocombiner=true', '-Dpig.accumulative.batchsize=5'],
                    'pig' => q\a = load ':INPATH:/singlefile/votertab10k' using PigStorage() as (name, age:int, registration, contributions);
e = group a by name  parallel 8;
f = foreach e generate group,  COUNT(a), MAX(a.contributions), MIN(a.contributions) ;
store f into ':OUTPATH:';\,
                    'sql' => "select name,  count(contributions), max(contributions), min(contributions)  from votertab10k group by name;",
                    },
                    {
                    'num' => 3,
                    'java_params' => ['-Dpig.exec.nocombiner=true', '-Dpig.accumulative.batchsize=5'],
                    'pig' => q\a = load ':INPATH:/singlefile/votertab10k' using PigStorage() as (name, age:int, registration, contributions);
e = group a by name  parallel 8;
f = foreach e generate group,  (MAX(a.contributions)-MIN(a.contributions))*COUNT(a) ;
store f into ':OUTPATH:';\,
                    'sql' => "select name,  (max(contributions)- min(contributions))*count(contributions)  from votertab10k group by name;",
                    },
                    {
                    'num' => 4,
                    'java_params' => ['-Dpig.exec.nocombiner=true', '-Dpig.accumulative.batchsize=5'],
                    'pig' => q\a = load ':INPATH:/singlefile/votertab10k' using PigStorage() as (name, age:int, registration, contributions);
e = group a by name  parallel 8;
f = foreach e { g = distinct a.age; generate group,  COUNT(g);} 
store f into ':OUTPATH:';\,
                    'sql' => "select name,  count(distinct age)  from votertab10k group by name;",
                    }
                ]
            },
            {
            'name' => 'PruneColumns',
            'floatpostprocess' => 1,
            'delimiter' => '	',
            'tests' => [
                    {
                    'num' => 1,
                    'pig' => q\
a = load ':INPATH:/singlefile/studenttab20m' using PigStorage() as (name, age, gpa);
b = foreach a generate age;
store b into ':OUTPATH:';\,
                    'sql' => "select age from studenttab20m;",
                    }
                ]
            },
            {
            'name' => 'Bzip',
            'floatpostprocess' => 1,
            'delimiter' => '	',
            'tests' => [
                    {
                    # test reading and writing out files with .bz2 extension
                    'num' => 1,
                    'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
store a into ':OUTPATH:.intermediate.bz2';
b = load ':OUTPATH:.intermediate.bz2';
store b into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k;",
                    },
                    {
                    # test reading and writing with .bz extension
                    'num' => 2,
                    'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
store a into ':OUTPATH:.intermediate.bz';
b = load ':OUTPATH:.intermediate.bz';
store b into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k;",
                    },
                ]
            },
            {
            'name' => 'Scalar',
            'floatpostprocess' => 1,
            'delimiter' => '	',
            'tests' => [
                    {
                    # test scalar in foreach (most common)
                    'num' => 1,
                    'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = group a all;
c = foreach b generate AVG(a.gpa) as avg, MAX(a.gpa) as max;
y = foreach a generate name, (gpa - c.avg) / c.max;
store y into ':OUTPATH:';\,
                    'sql' => "select name, (gpa - (select AVG(gpa) from studenttab10k)) / (select MAX(gpa) from studenttab10k) from studenttab10k;",
                    },
                    {
                    # test scalar in filter
                    'num' => 2,
                    'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = group a all;
c = foreach b generate AVG(a.gpa) as avg;
y = filter a by gpa > c.avg;
store y into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where gpa > (select AVG(gpa) from studenttab10k);",
                    },
                    {
                    # test scalar with two branch
                    'num' => 3,
                    'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = group a all;
c = foreach b generate AVG(a.age) as avg;
x = load ':INPATH:/singlefile/votertab10k' using PigStorage() as (name, age, registration, contributions);
y = filter x by age > c.avg;
store y into ':OUTPATH:';\,
                    'sql' => "select * from votertab10k where age > (select AVG(age) from studenttab10k);",
                    },
                    {
                    # test with scalar from two inputs
                    'num' => 4,
                    'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = group a all;
c = foreach b generate AVG(a.age) as avg;
d = load ':INPATH:/singlefile/votertab10k' using PigStorage() as (name, age, registration, contributions);
e = group d all;
f = foreach e generate AVG(d.age) as avg;
y = foreach a generate age/c.avg, age/f.avg;
store y into ':OUTPATH:';\,
                    'sql' => "select age/(select AVG(age) from studenttab10k), age/(select AVG(age) from votertab10k) from studenttab10k;",
                    },
                ]
            },
            {
            'name' => 'Scripting',
            'floatpostprocess' => 1,
            'delimiter' => '	',
            'tests' => [
                    {
                    # test common
                    'num' => 1,
                    'pig' => q\
register ':SCRIPTHOMEPATH:/python/scriptingudf.py' using jython as myfuncs;
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age:int, gpa:double);
b = foreach a generate myfuncs.square(age);
store b into ':OUTPATH:';\,
                    'sql' => "select age*age from studenttab10k;",
                    },
                    {
                    # test common
                    'num' => 2,
                    'pig' => q\
register ':SCRIPTHOMEPATH:/python/scriptingudf.py' using jython as myfuncs;
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = foreach a generate (chararray)name;
c = distinct b;
d = foreach c generate myfuncs.concat(name) as name;
e = order d by name;
store e into ':OUTPATH:';\,
                    'sql' => "select distinct (name||name) from studenttab10k;",
                    'sortArgs' => ['-t', '	'],
                    },
                ]
            },
            {
            'name' => 'Native',
            'delimiter' => '	',
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
			'ignore' => q/These tests need reworked.  They assume the existence
			of files to be removed, but fail if the files aren't there./,
            'tests' => [
                    {
                    # test common
                    'num' => 1,
                    'pig' => q\
fs -rmr table_testNativeMRJobSimple_input
fs -rmr table_testNativeMRJobSimple_output
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = mapreduce ':HADOOPHOME:/hadoop-examples.jar' Store a into 'table_testNativeMRJobSimple_input' Load 'table_testNativeMRJobSimple_output' `wordcount table_testNativeMRJobSimple_input table_testNativeMRJobSimple_output`;
store b into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1=2;",
                    },
                    {
                    # test complex
                    'num' => 2,
                    'pig' => q\
fs -rmr table_testNativeMRJobSimple_input
fs -rmr table_testNativeMRJobSimple_output
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = foreach a generate name;
c = distinct b;
d = mapreduce ':HADOOPHOME:/hadoop-examples.jar' Store c into 'table_testNativeMRJobSimple_input' Load 'table_testNativeMRJobSimple_output' as (name:chararray, count: int) `wordcount table_testNativeMRJobSimple_input table_testNativeMRJobSimple_output`;
e = order d by name;
store e into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1=2;",
                    'sortArgs' => ['-t', '	'],
                    },
                    {
                    # test streaming
                    'num' => 3,
                    'pig' => q\
fs -rmr table_testNativeMRJobSimple_input
fs -rmr table_testNativeMRJobSimple_output
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = mapreduce ':HADOOPHOME:/hadoop-streaming.jar' Store a into 'table_testNativeMRJobSimple_input' Load 'table_testNativeMRJobSimple_output' as (name:chararray, count: int) `-input table_testNativeMRJobSimple_input -output table_testNativeMRJobSimple_output -mapper /bin/cat -reducer /usr/bin/wc`;
store b into ':OUTPATH:';\,
                    'sql' => "select * from studenttab10k where 1=2;",
                    },
                ]
            },
            {
            'name' => 'Partitioner',
            'delimiter' => '	',
            'tests' => [
                    {
                    # test group
                    'num' => 1,
                    'exectype' => 'mapred', # since this join will run out of memory in local mode
                    'pig' => q\register :FUNCPATH:/testudf.jar;
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age:int, gpa);
b = group a by age PARTITION BY org.apache.pig.test.utils.SimpleCustomPartitioner2 parallel 2;
c = foreach b generate group, COUNT(a);
store c into ':OUTPATH:';\,
                    'sql' => "select age, COUNT(*) from studenttab10k group by age;",
					'verify_with_pig' => 1,
					'verify_pig_version' => 'old',
                    },
                ]
            },
            {

# 1 Test that a nested foreach gives instant feedback: after user issue the foreach statement in Grunt  	   	  
# 2 Test that a nested foreach gives instant feedback: as part of execution: when we run this foreach statement, we will dump the schema for the nested alias 	 	 
# 3 Describe single Alias resulting from a nested Foreach 	 	 
# 4 Describe multiple Alias resulting from a nested Foreach 	 	 
# 5 Describe resulting from a nested Foreach that contains a positional parameter 	 	 
# 6 Describe for child Alias resulting from a nested Foreach where the child alias had multiple assignments 	  	The expected behavior is that the last assignment will destermine the result of the describe statement.
# 7 Describe for an Alias resulting from a nested Foreach where the projection for the nested alias is empty 	 	 
# 8 Describe within a foreach statement
# 9 Describe for alias with complex data types 
# 10 Describe that uses references an alias from an AS clause 

                'name' => 'NestedDescribe',
                'tests' => [
                        {
# 2 Test that a nested foreach gives instant feedback: as part of execution: when we run this foreach statement, we will dump the schema for the nested alias 	 	 
# 3 Describe single Alias resulting from a nested Foreach 	 	 
                        'num' => 1,
                        'pig' => q\
A = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
B = group A by name;
C = foreach B { D = distinct A.age; generate COUNT(D), group;}
describe C::D;
\,
                          ,'expected_out_regex' => "D: {age: bytearray}"

                      },{
# 2 Test that a nested foreach gives instant feedback: as part of execution: when we run this foreach statement, we will dump the schema for the nested alias 	 	 
# 7 Describe for an Alias resulting from a nested Foreach where the projection for the nested alias is empty 	 	 
                        'num' => 2,
                        'pig' => q\
A = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
B = group A by name;
C = foreach B { D = distinct A.age; E= filter D by age > 1000; generate COUNT(E), group;}
describe C;
\,
                          ,'expected_out_regex' => "C: {long,group: bytearray}"


                      },{
# 1 Test that a nested foreach gives instant feedback: after user issue the foreach statement in Grunt  	   	  
# 2 Test that a nested foreach gives instant feedback: as part of execution: when we run this foreach statement, we will dump the schema for the nested alias 	 	 
# 3 Describe single Alias resulting from a nested Foreach 	 	 
# 4 Describe multiple Alias resulting from a nested Foreach 	 	 
# 5 Describe resulting from a nested Foreach that contains a positional parameter 	 	 
                        'num' => 3,
                        'pig' => q\
A = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
B = group A by name;
C = foreach B { D = distinct A.$1; generate COUNT(D), group;}
describe C::D;
\,
                          ,'expected_out_regex' => "D: {age: bytearray}"


                      },
                ]

            }, { 
####################################################################
# SUB    : CastScalar
# FEATURE: adds functionality that allows to cast elements of a single-tuple relation into a scalar value.
# JIRA: Pig-1434 
#
# TEST ITEMS:
# 1 Test syntax
# 2 Test scalar for simple data type
# 3 Test scalar for complex data type: tuple, bag, map
# 4 Test implicit cast
# 5 Test explicit cast
# 6 Positional parameter
# 7 Cast within an aggregate function
# 8 Cast within an UDF function
# 9 Cast with a FOREACH
# 10 Cast with a FILTER
# 11 Cast with a SPLIT
# 12 Cast in a JOIN
# 13 Multiquery
# 14 Cast on a schema that cannot be inferred should result in bytearray
# 15 Replicated Join
# 16 Test operations such as R1 * (int)R1
# 17 CheckSingular(*)
# 18 missing field in scalar file
# 19 scalar referenced from an empty file
# 20 empty input directory
# 21 Single row vs Multiple Row
# 22 Cast on a multi-field tuple
# 23 Reference a non-scalar as a scalar
# 24 Test multiple loaders

        'name' => 'CastScalar',
        'floatpostprocess' => 1,
        'delimiter' => '	',
        'tests' => [
            {
# 2 Test scalar for simple data type
# 3 Test scalar for complex data type: tuple, bag, map
# 9 Cast with a FOREACH
#INPATH = /user/hadoopqa/pig/tests/data

            'num' => 1,
            'pig' => q# 
a = load ':INPATH:/singlefile/studenttab10k' as (name: chararray, age: int, gpa: float); 
b = group a all;
c = foreach b generate SUM(a.age) as total;
d = foreach a generate name, age+(double)c.total as d_sum;
e = order d  by name, d_sum;
store d into ':OUTPATH:';
#,
            'sql' => "
SELECT name, ( age+ (SELECT SUM(age) FROM studenttab10k) + 0.000) AS d_sum
FROM studenttab10k
ORDER BY name, d_sum
;
",
# 6 Positional parameter

            }, {

            'num' => 2,
            'pig' => q# 
a = load ':INPATH:/singlefile/studenttab10k' as (name: chararray, age: int, gpa: float); 
b = group a all;
c = foreach b generate SUM(a.age) as total;
d = foreach a generate name, age+(double)c.$0 as d_sum;
e = order d  by name, d_sum;
store d into ':OUTPATH:';
#,
            'sql' => "
SELECT name, ( age+ (SELECT SUM(age) FROM studenttab10k) + 0.000) AS d_sum
FROM studenttab10k
ORDER BY name, d_sum
;
",
# 2 Test scalar for simple data type
# 3 Test scalar for complex data type:map
# 9 Cast with a FOREACH
# 13 Multiquery
# 24 Test multiple loaders
#INPATH = /user/hadoopqa/pig/tests/data

            }, {

            'num' => 4
            ,'pig' => q? 


A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
C  = filter A by id == 10;
D = foreach A generate id, id+(long)C.id as some_sum;
E = order D by id;
store E into ':OUTPATH:';
?,
            'sql' => "
SELECT id, 
    ( id + ( SELECT  id FROM numbers WHERE id='10') )
FROM numbers
ORDER BY id;
",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
            }, {

#            'num' => 6,
             'ignore' => 'FIX: this test is not quite ready',

            'pig' => q? 

A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B  = group A by (intnum5, intnum100, id);
C  = filter B by A.id == 299;
tuple_scalar = limit C 1;
D = foreach A generate id, intnum+tuple_scalar.group.$1 as some_sum;
store  ':OUTPATH:';
?,
            'sql' => "
SELECT id, intnum + ( SELECT intnum100 FROM numbers WHERE id='299');
",
            }, {

# 4 Test implicit cast
# 10 Cast with a FILTER
#
# I set the benchmark to use "19" because pig trunkates during cast and sql rounds up.
            'num' => 7,
            'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, AVG(a.gpa)+20 as avg_gpa;
d = order c by avg_gpa;
simple_scalar = limit d 1;
f = filter a by age < (int) simple_scalar.avg_gpa;
g = order f by name, age, gpa;
store g into ':OUTPATH:';\,

            'sql' => "
SELECT name, age, ROUND ( CAST( gpa  as numeric ), 2 )
FROM studenttab10k
WHERE age <  20
ORDER BY name, age, gpa
;",
            'floatpostprocess' => 1,
            'delimiter' => '        ',

            }, {
# 5 Test explicit cast
# 10 Cast with a FILTER
            'num' => 8,

                        'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, AVG(a.age) AS average;
d = order c by average;
simple_scalar = limit d 1;
d = filter a by age > (int) simple_scalar.average;
e = foreach d generate name, age;
store e into ':OUTPATH:';
\,
                        'sql' => "
select name, age
from studenttab10k
where age > (
   select avg(age) as average
   from studenttab10k
   group by name 
   order by average
   limit 1
) 
;
",

            'floatpostprocess' => 1,
            'delimiter' => '        ',

            }, {
# 5 Test explicit cast
# 6 Positional parameter
                        'num' => 9,
                        'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, AVG(a.age) AS average;
d = order c by average;
simple_scalar = limit d 1;
d = filter a by age > (int) simple_scalar.$1;
e = foreach d generate name, age;
store e into ':OUTPATH:';
\,
                        'sql' => "
select name, age
from studenttab10k
where age > (
   select avg(age) as average
   from studenttab10k
   group by name 
   order by average
   limit 1
) 
;
",

            'floatpostprocess' => 1,
            'delimiter' => '        ',

            }, {
# 4 Test implicit cast
# 6 Positional parameter
# 10 Cast with a FILTER
                        'num' => 10,
                        'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, AVG(a.age) AS average;
d = order c by average;
simple_scalar = limit d 1;
d = filter a by age >  simple_scalar.$1;
e = foreach d generate name, age;
store e into ':OUTPATH:';
\,
                        'sql' => "
select name, age
from studenttab10k
where age > (
   select avg(age) as average
   from studenttab10k
   group by name 
   order by average
   limit 1
) 
;
",

            'floatpostprocess' => 1,
            'delimiter' => '        ',

            }, {
# 4 Test implicit cast
# 6 Positional parameter
# 11 Cast with a SPLIT
            'num' => 11,
            'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
b = group a by name;
c = foreach b generate group, AVG(a.age) AS average;
d = order c by average;
simple_scalar = limit d 1;
split a into X1 if age > (int) simple_scalar.$1, X2 if age < 20;
split a into X3 if age > (int) simple_scalar.$1, X4 if age > 70;

store X1 into ':OUTPATH:.1';
store X2 into ':OUTPATH:.2';
store X3 into ':OUTPATH:.3';
store X4 into ':OUTPATH:.4';
\,
            'sql' => "
SELECT name, age, ROUND ( CAST( gpa  as numeric ), 2 )FROM studenttab10k
where age > (
   select avg(age) as average
   from studenttab10k
   group by name 
   order by average
   limit 1
) 
;


SELECT name, age, ROUND( CAST( gpa  as numeric), 2) FROM studenttab10k WHERE age < 20;

SELECT name, age, ROUND ( CAST( gpa  as numeric ), 2 )FROM studenttab10k
where age > (
   select avg(age) as average
   from studenttab10k
   group by name 
   order by average
   limit 1
) 
;

SELECT name, age, ROUND( CAST( gpa  as numeric), 2) FROM studenttab10k WHERE age > 70;
",
            'floatpostprocess' => 1,
            'delimiter' => '        ',

                 }, {
# 4 Test implicit cast
# 6 Positional parameter
# 12 Cast with a JOIN
            'num' => 12,
            'pig' => q\
a = load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
b = load ':INPATH:/singlefile/votertab10k' as (name, age, registration, contributions);
c = filter a by age < 20;
d = filter b by age < 20;
simple_scalar = limit d 1;
e = join c by name, d by name;
f= filter e by c::age <(int)simple_scalar.age;
store f into ':OUTPATH:';\,
            'sql' => "
select a.name, a.age, a.gpa, b.name, b.age, b.registration, b.contributions
from studenttab10k as a join votertab10k as b using(name)
where a.age < 20
and b.age < 20
and a.age < ( select age from studenttab10k where age < 20 order by name limit 1 );",
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
                   },
                ]

                },{
                 
                'name' => 'udf_TOBAGandTOTUPLE',
                'sortResults' => 1,
                'floatpostprocess' => 1,
                'delimiter' => '	',
                'tests' => [
                        {
# TEST : resulting schema for TOBAG/TOTUPLE with simple types
# TEST : resulting schema for TOBAG/TOTUPLE with positional parameters
# TEST : resulting schema for various projects using a combination of TOBAG/TOTUPLE and standard projections
# TEST : resulting schema for various projects using a combination of TOBAG/TOTUPLE using AS clause

						'num' => 1
                        ,'pig' => q?
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B = limit A 10;
Gen1 = FOREACH B GENERATE $0, $1, $2 ;
GroupById = GROUP B BY id;

B1  = foreach B generate TOBAG( intnum1000, id, intnum5); 
B3 = foreach B generate TOBAG( $0, $1, $2); 
T1= foreach B generate TOTUPLE( intnum1000, id, intnum5); 
T2= foreach B generate TOTUPLE( $0, $1, $2); 
T3 = foreach B generate TOTUPLE( $0, $0, $0); 
T4= foreach B generate TOBAG($0, $1, $2), TOTUPLE($3, $4, $5), $6, $7;
T5= foreach B generate $0, $1, TOTUPLE($2, $3, $4), TOBAG($5, $6), $7;
T6= foreach B generate $0,  TOTUPLE($0, $0, $0), TOBAG($0, $0), $0 AS duplicate;
describe Gen1;
describe GroupById;
describe B1;
describe B3;
describe T1;
describe T2;
describe T3;
describe T4;
describe T5;
describe T6;
?
#                         ,'expected_out_regex'  => 'B1: {{int}}'
#                         ,'expected_out_regex'  => 'B3: {{int}}'
#                         ,'expected_out_regex'  => 'T1: {org.apache.pig.builtin.totuple_id_.*: (intnum1000: int,id: int,intnum5: int)}'
#                         ,'expected_out_regex'  => 'T2: {org.apache.pig.builtin.totuple_id_.*: (intnum1000: int,id: int,intnum5: int)}'
#                         ,'expected_out_regex'  => 'T3: {org.apache.pig.builtin.totuple_intnum1000.*: (intnum1000: int,intnum1000: int,intnum1000: int)}'
#                         ,'expected_out_regex'  => 'T4: {{int},org.apache.pig.builtin.totuple_intnum100.*: (intnum100: int,intnum: int,longnum: long),floatnum: float,doublenum: double}'
#                         ,'expected_out_regex'  => 'T5: {intnum1000: int,id: int,org.apache.pig.builtin.totuple_intnum100.*: (intnum5: int,intnum100: int,intnum: int).*{NULL}.*doublenum: double}'
                          ,'expected_out_regex'  => "T6:.*{intnum1000:.*int,org.apache.pig.builtin.totuple_intnum1000_.*:.*(intnum1000:.*int,intnum1000:.*int,intnum1000:.*int).*{int}.*duplicate:.*int}"




                        }, {
# TEST : bag of mixed data types
# TEST : Order 
# TEST : positional parameters
			'num' => 2
                        ,'pig' => q?
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
C   = foreach A generate TOBAG( id, floatnum, doublenum ); 
D   = foreach A generate TOBAG( id, intnum);
E   = foreach A generate TOBAG( (float) id,floatnum );
F   = foreach A generate TOBAG( (long) id,longnum );
G   = foreach A generate TOBAG( (double) id,doublenum );
describe C;
describe D;
describe E;
describe F;
describe G;
?
                         ,'expected_out_regex'  => 'C: {{NULL}}'
                         ,'expected_out_regex'  => 'D: {{int}}'
                         ,'expected_out_regex'  => 'E: {{float}}'
                         ,'expected_out_regex'  => 'F: {{long}}'
                         ,'expected_out_regex'  => 'G: {{double}}'

			}, {
# TEST : TOBAG/TOTUPLE with simple types
# TEST : TOBAG/TOTUPLE with positional parameters
# TEST : various projects using a combination of TOBAG/TOTUPLE and standard projections
# TEST : various projects using a combination of TOBAG/TOTUPLE using AS clause
			 			'num' => 3
                        ,'pig' => q?
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B = limit A 10;
B1  = foreach B generate TOBAG( intnum1000, id, intnum5); 
B2 = foreach B generate TOBAG( $0, $1, $2); 
T1= foreach B generate TOTUPLE( intnum1000, id, intnum5); 
T2= foreach B generate TOTUPLE( $0, $1, $2); 
T3 = foreach B generate TOTUPLE( $0, $0, $0); 
T4= foreach B generate TOBAG($0, $1, $2), TOTUPLE($3, $4, $5), $6, $7;
T5= foreach B generate $0, $1, TOTUPLE($2, $3, $4), TOBAG($5, $6), $7;
T6= foreach B generate $0,  TOTUPLE($0, $0, $0), TOBAG($0, $0), $0 AS duplicate;
Gen1 = FOREACH B GENERATE $0, $1, $2 ;
GroupById = GROUP B BY id;
store Gen1 into ':OUTPATH:.1';
store GroupById into ':OUTPATH:.2';
store B1 into  ':OUTPATH:.3';
store B2 into  ':OUTPATH:.4';
store T1 into ':OUTPATH:.5';
store T2 into ':OUTPATH:.6';
store T3 into ':OUTPATH:.7';
store T4 into ':OUTPATH:.8';
?
#store B into  '/user/hadoopqa/pig/tests/out/Udf1/B.out';
#store B1 into  '/user/hadoopqa/pig/tests/out/Udf1/B1.out';
#store B2 into  '/user/hadoopqa/pig/tests/out/Udf1/B2.out';
#store T1 into '/user/hadoopqa/pig/tests/out/Udf1/T1.out';
#store T2 into '/user/hadoopqa/pig/tests/out/Udf1/T2.out';
#store T3 into '/user/hadoopqa/pig/tests/out/Udf1/T3.out';
#store T4 into '/user/hadoopqa/pig/tests/out/Udf1/T4.out';
#store T5 into '/user/hadoopqa/pig/tests/out/Udf1/T5.out';

#Benchmarks are checked in, this is just to ensure validation happens
                        ,'sql' => "select name, age, gpa from studenttab10k;
                                  select name, age, gpa from studenttab10k;
                                  select name, age, gpa from studenttab10k;
                                  select name, age, gpa from studenttab10k;
                                  select name, age, gpa from studenttab10k;
                                  select name, age, gpa from studenttab10k;
                                  select name, age, gpa from studenttab10k;
                                  select name, age, gpa from studenttab10k;",
						'verify_with_pig' => 1,
						'verify_pig_version' => 'old',

                        }, {
# TEST : cast for TOTUPLE/TOBAG
						 'num' => 4
                        ,'pig' => q?
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B= limit A 10;
C = foreach B generate $0,  TOTUPLE((int) $0, (long) $0, (double) $0), TOBAG( (float) $0, (chararray) $0), $0;
store C into  ':OUTPATH:';
?
                         ,'expected_err_regex'  => 'ERROR 1108: Duplicate schema alias'
                         ,'rc' => 6

                        }, {
# TEST : cast for TOTUPLE/TOBAG
						'num' => 5
                        ,'pig' => q?
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B= limit A 1;
C = foreach B generate $0,  TOTUPLE((int) $0);
D = foreach B generate $0,  TOTUPLE((long) $0);
E = foreach B generate $0,  TOTUPLE((double) $0);
F = foreach B generate $0,  TOTUPLE((float) $0);
G = foreach B generate $0,  TOTUPLE((chararray) $0);
store B into  ':OUTPATH:.1';
store C into  ':OUTPATH:.2';
store D into  ':OUTPATH:.3';
store E into  ':OUTPATH:.4';
store F into  ':OUTPATH:.5';
store G into  ':OUTPATH:.6';
?
#PLace holder, actual bm is checked in to svn
                        ,'sql' => "
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k;",
						'verify_with_pig' => 1,
						'verify_pig_version' => 'old',

                        }, {

#TEST more complicated nested functions such as TOTUPLE(TOBAG())
#TEST more complicated nested functions such as TOBAG(TOTUPLE())
#TEST more complicated nested functions such as TOTUPLE(TOTUPLE())
#TEST more complicated nested functions such as TOBAG(TOBAG())
			'num' => 6
                        ,'pig' => q?
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B = limit A 10;
tint = foreach B generate  TOTUPLE( TOBAG( $1, $2, $3),TOTUPLE($3, $4, $5) );
bint = foreach B generate  TOTUPLE( TOBAG( $1, $2, $3),TOBAG($3, $4, $5) );
binb = foreach B generate  TOBAG( TOBAG( $1, $2, $3),TOBAG($3, $4, $5) );
tinb = foreach B generate  TOTUPLE( TOBAG( $1, $2, $3),TOBAG($3, $4, $5) );
store B into  ':OUTPATH:.1';
store tint into  ':OUTPATH:.2';
store bint into  ':OUTPATH:.3';
store binb into  ':OUTPATH:.4';
store tinb into  ':OUTPATH:.5';
?

                        ,'sql' => "
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k;",
						'verify_with_pig' => 1,
						'verify_pig_version' => 'old',
                        }, {
#TEST arithmetic operation in TOTUPLE and TOBAG
#TEST aggregate funcion - NOT IMPLEMENTED
#TEST tuple with 50+ items
#TEST with null
						'num' => 7
                        ,'pig' => q?
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B = limit A 10;
B1= foreach B generate  TOTUPLE( $1, $2, $3);
T1= foreach B generate  TOTUPLE( $1, $2, $3);
R1= foreach B generate  TOTUPLE( $1, $0+1, $0+2, $0+3),TOBAG($0+4, $0+1 );
R2= foreach B generate  TOTUPLE( $0, $1, $2, $3, $4, $5, $6, $7, (int) 8, (int) 9 , $1, $2, $3, $4, $5, $6, $7, (int) 19, (int) 20, $0, $1, $2, $3, $4, $5, $6, $7 , (int) 29, (int) 30, $0, $1, $2, $3, $4, $5, $6, $7, (int) 39, (int) 40 , $1, $2, $3, $4, $5, $6, $7, (int) 19, (int) 20, $0, $1, $2, $3, $4, $5, $5, $7 );

R3= foreach B generate $0, TOTUPLE(0,0,0),  TOBAG( 0, 0 );
R4= foreach B generate $0, TOTUPLE(null, id, null),  TOBAG( id, null, id,null );

describe R1;
describe R2;
describe R3;
describe R4;

store B into  ':OUTPATH:.1';
store B1 into ':OUTPATH:.2';
store R1 into ':OUTPATH:.3';
store R2 into ':OUTPATH:.4';
store R3 into ':OUTPATH:.5';
store R4 into ':OUTPATH:.6';
?

                        ,'sql' => "
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k;",
						'verify_with_pig' => 1,
						'verify_pig_version' => 'old',

#                         ,'expected_out_regex'  => 'R1: {org.apache.pig.builtin.totuple_id_13: (id: int,int,int,int),{int}}'
#                         ,'expected_out_regex'  => 'R2: {org.apache.pig.builtin.totuple_id_20: (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double,int,int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double,int,int,intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double,int,int,intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double,int,int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double,int,int,intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,longnum: long,doublenum: double)}'
#                         ,'expected_out_regex'  => 'R3: {intnum1000: int,org.apache.pig.builtin.totuple_27: (int,int,int),{int}}'
#                         ,'expected_out_regex'  => 'R4: {intnum1000: int,org.apache.pig.builtin.totuple_id_34: (bytearray,id: int,bytearray),{NULL}}'



                        }, {
# TESST more TOTUPLE and TOBAG nested combinations
						'num' => 8
                        ,'pig' => q?
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B = limit A 10;
C = foreach B generate TOBAG( $0, $1, $2); 
T1= foreach B generate  TOTUPLE( TOBAG( $1, $2, $3),TOTUPLE($3, $4, $5) );
T2= foreach B generate  TOTUPLE( TOBAG( $1, $2, $3),TOBAG($3, $4, $5) );
T3= foreach B generate  TOBAG( TOTUPLE( $1, $2, $3), TOTUPLE($4,$5), TOTUPLE($6,$7));
store B  into ':OUTPATH:.1';
store C  into ':OUTPATH:.2';
store T1 into ':OUTPATH:.3';
store T2 into ':OUTPATH:.4';
store T3 into ':OUTPATH:.5';
?

                        ,'sql' => "
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k; 	
select name from studenttab10k;",
						'verify_with_pig' => 1,
						'verify_pig_version' => 'old',

                        }, {
#TEST negative test case: out of bounds positional parameter
# EVERYTHING IS CORRECT
			'num' => 9
                        ,'pig' => q?
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B = limit A 10;
C = foreach B generate $0, $1, TOTUPLE($2, $998, $4), TOBAG($5, $6), $7;
?
                         ,'expected_err_regex'  => 'Out of bound access.*non-existent column: 998'
                        }, {
#TEST negative test case: out of bounds positional parameter
# EVERYTHING IS CORRECT
			'num' => 10
                        ,'pig' => q?
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B = limit A 10;
C = foreach B generate $0, $1, TOBAG($5, $999), $7;
?
                         ,'expected_err_regex'  => 'Out of bound access.*non-existent column: 999'

                        }, 

                ] # end of tests

            },{

# Test Union using merge with Simple data types
	        'name' => 'MergeOperator',
			'verify_with_pig' => 1,
			'verify_pig_version' => 'old',
	        'tests' => [
			{
# - identical schema and duplicate data
# Test Union using merge with Simple data types     | numbers has all the numeric types
# Test Union using merge where schema is identical  | A&B have identical schema
# Test Union using merge where data intersect       | C and D both contain data id<20
# Test Union using merge where data do not intersect| C and D both have exclusive data in intnum5
# Test Union using merge where schema intersect     | A&B have intersecting schema
# Test Union using merge where schema do not intersect |  results of U2 |
# /user/hadoopqa/pig/tests/data/
			'num' => 1 
			,'pig' => q\
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
C  = filter A by intnum5 < 3 and id < 20;
D  = filter B by intnum5 > 3 and id > 15 and id < 40;
U1 = union onschema D, C;
E  = order U1 by intnum5, id;
F  = foreach E generate id, intnum5;
store F into ':OUTPATH:';
\ 
			,'sql' => "
SELECT id, intnum5 FROM numbers WHERE id IN (
   SELECT id FROM numbers WHERE intnum5 < 3 AND id < 20
   UNION
   SELECT id FROM numbers WHERE intnum5 > 3 AND id > 15 AND id < 40
) ORDER BY intnum5, id
;" 
			,'floatpostprocess' => 1
			,'delimiter' => '	'

			},{
# - identical schema and duplicate data
# Test Union using merge with Simple data types     | numbers has all the numeric types
# Test Union using merge where schema is identical  | A&B have identical schema
# Test Union using merge where data intersect       | C and D both contain data id<20
# Test Union using merge where data do not intersect| C and D both have exclusive data in intnum5
# Test Union using merge where schema intersect     | A&B have intersecting schema
# Test Union using merge where schema do not intersect |  results of U2 |
#INVESTIGATE: REsults Differ
			'num' => 2 
		       ,'ignore' => 'Bugzilla(4151306)'
		       ,'pig' => q\
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as ( Aintnum1000: int,Mid: int,Mintnum5: int,Mintnum100: int,Aintnum: int,Mlongnum: long,Mfloatnum: float,Mdoublenum: double);
B  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as ( Bintnum1000: int,Mid: int,Mintnum5: int,Mintnum100: int,Bintnum: int,Mlongnum: long,Mfloatnum: float,Mdoublenum: double);
C1 = filter A by Mintnum5 < 3 and Mid < 20;
C2 = filter B by Mid > 950;
U1 = union onschema C1, C2;
describe U1;
store U1 into ':OUTPATH:.1';

D1 = cogroup C1 by (Mintnum5, Mid), C2 by (Mintnum5, Mid) ;
describe D1;
D2 = cogroup C1 by (Mintnum5, Mid), C2 by (Mintnum5, Mid) ;
describe D2;
U2 = union onschema D1, D2;
describe U2;
E  = foreach U2 generate flatten((SIZE(C1)==0? null: C1)), flatten((SIZE(C2)==0? null: C2));
describe E;
store E into ':OUTPATH:.2';
\ 

			,'sql' => "
SELECT A.intnum1000,A.id,A.intnum5,A.intnum100,A.intnum,A.longnum,A.floatnum,A.doublenum,B.intnum1000 as Bintnum1000,B.intnum as Bintnum 
FROM numbers A, numbers B
WHERE ( A.intnum5 <3 AND A.id < 20) OR B.id > 950;

SELECT intnum1000,id,intnum5,intnum100,null,longnum,floatnum,doublenum
FROM numbers 
WHERE floatnum > 4800 AND intnum5=1
UNION
SELECT intnum1000,id,intnum5,intnum100,intnum,longnum,floatnum,doublenum,null
FROM numbers 
WHERE floatnum > 4800 AND intnum5=3;
SELECT A.intnum1000,A.id,A.intnum5,A.intnum100,A.intnum,A.longnum,A.floatnum,A.doublenum,B.intnum1000 as Bintnum1000,B.intnum as Bintnum 
FROM numbers A, numbers B
WHERE ( A.intnum5 <3 AND A.id < 20) OR B.id > 950;

SELECT id, intnum5 FROM numbers WHERE id IN (
   SELECT id FROM numbers WHERE intnum5 < 3 AND id < 20
   UNION
   SELECT id FROM numbers WHERE id > 20
) ORDER BY intnum5, id;" 
			,'floatpostprocess' => 1
			,'delimiter' => '	'

# The resulst of E are empty
# Test Union using merge where result set is empty       | results of H |
			},{

				'num' => 3,
				'ignore' => 'Test aborts with typechecker error',
		       ,'pig' => q\
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as ( Aintnum1000: int,Mid: int,Mintnum5: int,Mintnum100: int,Aintnum: int,Mlongnum: long,Mfloatnum: float,Mdoublenum: double);
B  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as ( Bintnum1000: int,Mid: int,Mintnum5: int,Mintnum100: int,Bintnum: int,Mlongnum: long,Mfloatnum: float,Mdoublenum: double);
C1 = filter A by Mintnum5 < 3 and Mid < 20;
C2 = filter B by Mid > 4980;
U1 = union onschema C1, C2;
describe U1;
Result  = foreach U1 generate Aintnum1000, Bintnum1000, Aintnum, Bintnum, Mid, Mintnum5, Mintnum100, Mlongnum, Mfloatnum , Mdoublenum;
store Result into ':OUTPATH:.1';

D1 = cogroup C1 by (Mintnum5, Mid), C2 by (Mintnum5, Mid) ;
describe D1;
D2 = cogroup C1 by (Mintnum5, Mid), C2 by (Mintnum5, Mid) ;
U2 = union onschema D1, D2;
describe U2;
EmptyResult  = foreach U2 generate flatten((SIZE(C1)==0? null: C1)), flatten((SIZE(C2)==0? null: C2));
UEmpty = union onschema D1, EmptyResult;
describe EmptyResult;
store UEmpty into ':OUTPATH:.2';\ 

			,'sql' => "
(
SELECT intnum as Aintnum1000, null as Bintnum1000, intnum as Aintnum, null as Bintnum, id as Mid,intnum5 as Mintnum5,intnum100 as Mintnum100, longnum as Mlongnum, floatnum as Mfloatnum,doublenum as Mdoublenum
FROM numbers
WHERE  intnum5 < 3 and id < 20 
) UNION (
SELECT null as Aintnum1000, intnum100 as Bintnum1000, null as Aintnum, intnum as Bintnum, id as Mid,intnum5 as Mintnum5,intnum100 as Mintnum100, longnum as Mlongnum, floatnum as Mfloatnum,doublenum as Mdoublenum
FROM numbers
WHERE id > 4980
);

SELECT *
FROM numbers 
WHERE id > 999999;"
			,'floatpostprocess' => 1
			,'delimiter' => '	'


			},{
# - identical schema and duplicate data
# Test Union using merge with Simple data types     | numbers has all the numeric types
# Test Union using merge where schema is identical  | A&B have identical schema
# Test Union using merge where data intersect       | C and D both contain data id<20
# Test Union using merge where data do not intersect| C and D both have exclusive data in intnum5
# Test Union using merge where schema intersect     | A&B have intersecting schema
# Test Union using merge where schema do not intersect |  results of U2 |
				'num' => 4,
				'ignore' => 'Error message problem, not clear'
		       ,'pig' => q\
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
C1 = filter A by intnum5 < 3 and id < 20;
C2 = filter A by intnum5 < 3 and id < 20;
D  = cogroup C1 by (intnum5, id), C2 by (intnum5, id) ;
E  = foreach D generate flatten(C1), flatten(C2);
F  = filter B by intnum5 > 3 and id > 15 and id < 40;
U2 = union onschema E, F;
store U2 into ':OUTPATH:';\ 

                        ,'expected_err_regex'=>"ERROR 1025:.*match"

			},{

# Union using merge that have differing permutations of the schema  | A&B 
# Test Union using merge with Simple data types          | numbers has all the numeric types
#INVESTIGATE: REsults Differ
			 'num' => 7 
			,'pig' => q\
X  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
A = foreach X generate intnum1000 as A_intnum1000, id, intnum5, intnum as A_intnum, longnum, floatnum, doublenum;
B = foreach X generate doublenum, floatnum, longnum, id, intnum5, intnum100 AS B_intnum100;
C1 = filter A by intnum5 == 1;
C2 = filter C1 by floatnum > 4800.0F;
store C2 into ':OUTPATH:.1';
D1 = filter B by intnum5 == 3;
D2 = filter D1 by floatnum > 4800.0F;
store D2 into ':OUTPATH:.2';
U = union onschema C2, D2;
store U into ':OUTPATH:.3';\
			,'sql' => "
SELECT intnum1000 as A_intnum1000, id, intnum5, intnum as A_intnum, longnum, floatnum, doublenum
FROM numbers 
WHERE floatnum > 4800 AND intnum5=1;

SELECT doublenum, floatnum, longnum, id, intnum5, intnum100 as B_intnum100
FROM numbers 
WHERE floatnum > 4800 AND intnum5=3;

SELECT intnum1000 as A_intnum1000, id, intnum5, intnum as A_intnum, longnum, floatnum, doublenum, null as B_intnum100
FROM numbers 
WHERE floatnum > 4800 AND intnum5=1
UNION
SELECT null as A_intnum1000, id, intnum5, null as A_intnum, longnum, floatnum, doublenum, intnum100 as B_intnum100
FROM numbers 
WHERE floatnum > 4800 AND intnum5=3;" 
			,'floatpostprocess' => 1
			,'delimiter' => '	'

			},{
# Test implicit cast for simple types
# Test Union using merge with Simple data types          | numbers has all the numeric types
# Test Union using merge where schema intersect	         | A&B 
# Union using merge that have differing permutations of the schema  | A&B 
# Union using merge that have differing permutations of the schema  | A&B 
# Union using merge that have different arity such as: L1(a,c),L2(a,b,c,d) | A&B have different arity
# Test Union using data where schema intersect 	  	 | U2 source data intersects
# Test multiple Unions                                   | U source data is disjoint

			'num' => 8,
			'pig' => q\
A = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: long,id: int,intnum5: double,intnum100: int,intnum: int,longnum: int,floatnum: long,doublenum: float);
C = foreach B generate id AS id, id AS id2, id AS id3;
A1 = filter A by id > 450 AND id < 460;
B1 = filter B by id > 550 AND id < 560;
C1 = filter C by id > 650 AND id < 660;
U = union onschema A, B, C;
Usorted= order U  by  id;
store Usorted into ':OUTPATH:';\,
			'sql' => "
SELECT CAST( intnum1000 as bigint),  id, CAST(intnum5 AS double precision), intnum100, intnum, CAST(longnum as bigint), CAST(floatnum as bigint), CAST( doublenum as float)
FROM numbers 
WHERE   id > 450  AND id < 460 
   OR   id > 550 AND id < 560 
   OR   id > 650 AND id < 660;
;" 
			,'floatpostprocess' => 1
			,'delimiter' => '	'

			},{
# Test Union using merge where the field names are the same but they are in a different order such as L1 ( a, b, c) L2 (b, c, a ) 	  	 
# Test Union using merge with Simple data types          | numbers has all the numeric types
# Test Union using merge where schema intersect	         | A&B have overlaping schema
# Union using merge that have different arity such as: L1(a,c),L2(a,b,c,d) |     A&B have different arity
# Test Union using data where schema intersect 	  	 | U2 source data intersects
# Test Union using data where schema do not intersect    | U1 source data is disjoint

#B = load ':OUTPATH:/MergeOperator_4_B.txt' using PigStorage(':') as ( doublenum: double ,floatnum: float ,longnum: long ,intnum100: int ,intnum1000: varchar ,id: int ,intnum: int ,intnum5: int)
			'num' => 9,
			'pig' => q\
A = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: chararray,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B = load ':INPATH:/types/numbers.txt' using PigStorage(':') as ( id: int,intnum5: int,intnum2: int,longnum: long,floatnum: float,doublenum: double);
C = filter A by intnum5 == 1;
D = filter A by intnum5 == 3;
E = filter A by intnum5 == 2;
F = filter A by intnum5 == 4;
G = filter A by intnum5 == 5;
U = union onschema C,D,E,F,G;
describe U;
H = filter U by id > 4980;
store H into ':OUTPATH:';\,
#SELECT SUM(id), SUM(intnum5), SUM(intnum100), SUM(intnum), SUM(longnum), SUM(floatnum), SUM(doublenum  FROM numbers GROUP BY intnum5;
			'sql' => "
SELECT intnum1000, id, intnum5, intnum100, intnum, longnum, floatnum, doublenum  FROM numbers WHERE id>4980 
;" 
			,'floatpostprocess' => 1
			,'delimiter' => '	'
                         },{
# - identical schema and duplicate data
# Test Union using merge with Simple data types     | numbers has all the numeric types
# Test Union using merge where schema is identical  | A&B have identical schema
# Test Union using merge where data intersect       | C and D both contain data id<20
# Test Union using merge where data do not intersect| C and D both have exclusive data in intnum5
# Test Union using merge where schema intersect     | A&B have intersecting schema
# Test Union using merge where schema do not intersect |  results of U2 |
                        'num' => 10
                        ,'pig' => q\
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
C  = filter A by intnum5 < 3 and id < 20;
D  = filter B by intnum5 > 3 and id > 15 and id < 40;
U1 = union onschema D, C;
E  = order U1 by intnum5, id;
F  = foreach E generate id, intnum5;
store F into ':OUTPATH:';\,
                        ,'sql' => "
SELECT id, intnum5 FROM numbers WHERE id IN (
   SELECT id FROM numbers WHERE intnum5 < 3 AND id < 20
   UNION
   SELECT id FROM numbers WHERE intnum5 > 3 AND id > 15 AND id < 40
) ORDER BY id, intnum5, id
;" 
                        ,'floatpostprocess' => 1
                        ,'delimiter' => '        '

                        },{

# Test Union using merge with a relation that is empty 	 
                        'num' => 11
                        ,'pig' => q\
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B  = filter A by intnum5 < 3 and id < 20;
C  = filter A by id > 99999;
D  = foreach C generate id, intnum5 as Cintnum5;
describe D;
U1 = union onschema B, D;
describe U1;
E  = order U1 by id,intnum5;
F  = foreach E generate id, intnum5, Cintnum5;
describe F;
store F into ':OUTPATH:';\
                        ,'sql' => "
SELECT id, intnum5, null as Cintnum5
FROM numbers 
WHERE intnum5 < 3 and id <20
ORDER BY id, intnum5;" 
# need to add this check but this aborts, fix driver? to allows both sql and regex
#                        ,'expected_out_regex' => "F: {id: int,intnum5: int,Cintnum5: int}"

                        },{

# Test Union using merge with a relation that is empty 	 
# Remove this once regex is fixed
                        'num' => 12,
						'ignore' => 'Error message has changed.',
                        ,'pig' => q\
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
B  = filter A by intnum5 < 3 and id < 20;
D  = foreach B generate id, intnum5 as Cintnum5;
describe D;
U1 = union onschema B, D;
describe U1;
describe U1;\
# need to add this check but this aborts, fix driver?
                        ,'expected_out_regex' => "E: {intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double,Cintnum5: int}"


                        },{
                # Results doctored, if you change this query you need to copy the
                        'num' => 14,
                        'pig' => q\register :FUNCPATH:/testudf.jar;
A = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
B = foreach A generate name, org.apache.pig.test.udf.evalfunc.Swap(name, age), TOKENIZE((chararray)name), org.apache.pig.test.udf.evalfunc.CreateMap((chararray)name, age);
N  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as (intnum1000: int,id: int,intnum5: int,intnum100: int,intnum: int,longnum: long,floatnum: float,doublenum: double);
C  = filter N by intnum5 < 3 and id < 20;
U = union onschema B, C;
describe U;
store U into ':OUTPATH:' using org.apache.pig.test.udf.storefunc.StringStore();\
                       ,'sql' => "select name, age, gpa from studenttab10k;"

			},{

			'num' => 15
		       ,'pig' => q\
A  = load ':INPATH:/types/numbers.txt' using PigStorage(':') as ( intnum1000: int,id: int,intnum5: int,intnum100: int,Aintnum: int,longnum: long,floatnum: float,doublenum: double);
empty  = filter A by id > 99999;
B  = filter A by id < 10;
U = union onschema B, empty;
describe U;
store U into ':OUTPATH:';\ 

			,'sql' => "
SELECT *
FROM numbers 
WHERE id < 10
;
"
			,'floatpostprocess' => 1
			,'delimiter' => '	'

		      }
		]

            },
			{

			# Test Union using merge with Simple data types
	        'name' => 'UdfDistributedCache',
            'tests' => [
            	{
            		'num' => 1,
                    'exectype' => 'mapred', # since distributed cache is not supported in local mode
                    'pig' => q?
                        register :FUNCPATH:/testudf.jar;
                        define udfdc org.apache.pig.test.udf.evalfunc.Udfcachetest(':INPATH:/singlefile/votertab10k#foodle');
                        a = load ':INPATH:/singlefile/studenttab10k' as (name, age, gpa);
                        b = limit a 1;
                        c = foreach b generate udfdc(age);
                        STORE c into ':OUTPATH:';?,

                    'sql' => "
                        select  'tom van buren', 68, 'socialist', 390.19;",
                        #from votertab10k;",
            	},
	        ]
            }
 
        ],
    },
;



